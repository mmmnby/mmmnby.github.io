<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spectrogram Player – Robust Phase Detection</title>
  <style>
    body { background: #111; color: #fff; font-family: sans-serif; margin: 0; text-align: center; }
    .controls { padding: 10px; }
    .controls > * { margin: 6px; font-size: 16px; }
    #timeStatus { margin-top: 6px; font-size: 14px; font-style: italic; }
    .canvasRowContainer { position: relative; display: inline-block; margin-bottom: 20px; }
    canvas.spectrogramCanvas { background: #000; display: block; }
    canvas.cursorOverlayCanvas { position: absolute; left: 0; top: 0; pointer-events: auto; }
    #playerControls { margin: 10px; display: none; }
    #playerControls button { margin: 0 6px; font-size: 16px; padding: 6px 12px; }
  </style>
</head>
<body>
  <h1>Spectrogram Player – Reliable Phase Transition</h1>

  <div class="controls">
    <input type="file" id="fileInput" accept=".mp3">
    <label> Speed:
      <select id="playbackSpeedSelect"><option>1</option><option>2</option><option>4</option><option>30</option><option>60</option><option>120</option></select> ×
    </label>
    <button id="startGenerateButton">Play (Phase 1)</button>
    <button id="pauseGenerateButton" disabled>Pause</button>
    <button id="exportButton">Download Spectrogram</button>
    <div id="timeStatus">No file loaded.</div>
    <div id="fileDurationStatus"></div>
  </div>

  <div id="rowsContainer"></div>

  <div id="playerControls">
    <button id="rewind15Seconds">◀ 15 s</button>
    <button id="playPauseButton">Play/Pause</button>
    <button id="forward15Seconds">15 s ▶</button>
  </div>

  <script>
    // Configuration constants
    const SCREEN_WIDTH = window.innerWidth;
    const ROW_HEIGHT = 300;
    const MINUTE_TICK_HEIGHT = 10;
    const LABEL_AREA_HEIGHT = 20;
    const USEFUL_CANVAS_HEIGHT = ROW_HEIGHT - MINUTE_TICK_HEIGHT - LABEL_AREA_HEIGHT;
    const PIXEL_LABEL_INTERVAL = 100;
    const LABEL_PADDING = 6;

    // DOM elements
    const fileInput = document.getElementById('fileInput');
    const playbackSpeedSelect = document.getElementById('playbackSpeedSelect');
    const startGenerateButton = document.getElementById('startGenerateButton');
    const pauseGenerateButton = document.getElementById('pauseGenerateButton');
    const exportButton = document.getElementById('exportButton');
    const timeStatus = document.getElementById('timeStatus');
    const fileDurationStatus = document.getElementById('fileDurationStatus');
    const rowsContainer = document.getElementById('rowsContainer');
    const playerControls = document.getElementById('playerControls');
    const rewind15Seconds = document.getElementById('rewind15Seconds');
    const playPauseButton = document.getElementById('playPauseButton');
    const forward15Seconds = document.getElementById('forward15Seconds');

    // State variables
    let generateAudio = null;
    let audioAnalyzer = null;
    let audioDataArray = null;
    let drawXPosition = 0;
    let finalRowWidth = 0;
    let hasSpectrogramFinished = false;
    let isGeneratePaused = false;
    let generateAnimationFrame = null;

    const spectrogramRows = [];
    const overlayRows = [];
    const rowTimestamps = [];

    let playbackAudio = null;
    let isPlaybackPlaying = false;

    // Utility: format seconds -> HhMmSs
    function formatTime(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = Math.floor(seconds % 60);
      return `${h}h${m}m${s}s`;
    }

    // Phase 1: update processing display
    function updateGenerateDisplay() {
      if (!generateAudio) return timeStatus.textContent = 'No file loaded.';
      const tCurrent = Number(generateAudio.currentTime);
      const tTotal = Number(generateAudio.duration) || 0;
      timeStatus.textContent = `Processing: ${formatTime(tCurrent)} / ${formatTime(tTotal)}`;
    }

    // Create a new spectrogram row + overlay
    function createSpectrogramRow() {
      const container = document.createElement('div');
      container.className = 'canvasRowContainer';

      const spectroCanvas = document.createElement('canvas');
      spectroCanvas.width = SCREEN_WIDTH;
      spectroCanvas.height = ROW_HEIGHT;
      spectroCanvas.className = 'spectrogramCanvas';
      const spectroCtx = spectroCanvas.getContext('2d');
      spectroCtx.fillStyle = '#000';
      spectroCtx.fillRect(0, 0, SCREEN_WIDTH, ROW_HEIGHT);

      const overlayCanvas = document.createElement('canvas');
      overlayCanvas.width = SCREEN_WIDTH;
      overlayCanvas.height = ROW_HEIGHT;
      overlayCanvas.className = 'cursorOverlayCanvas';
      const overlayCtx = overlayCanvas.getContext('2d');

      container.appendChild(spectroCanvas);
      container.appendChild(overlayCanvas);
      rowsContainer.appendChild(container);

      spectrogramRows.push({ canvas: spectroCanvas, ctx: spectroCtx });
      overlayRows.push({ canvas: overlayCanvas, ctx: overlayCtx });
      rowTimestamps.push(Number(generateAudio.currentTime));
      drawXPosition = 0;
    }

    // Phase 1: main draw loop with robust end detection
    function drawSpectrogramFrame() {
      if (!generateAudio || generateAudio.paused || isGeneratePaused) return;

      const tCurrent = Number(generateAudio.currentTime);
      const tTotal = Number(generateAudio.duration) || 0;

      // If finished playback, finalize and transition
      if ((tCurrent >= tTotal - 0.05) && !hasSpectrogramFinished) {
        finalRowWidth = drawXPosition;
        hasSpectrogramFinished = true;
        playerControls.style.display = 'block';
        setupPlaybackPhase();
        return;
      }

      audioAnalyzer.getByteFrequencyData(audioDataArray);

      if (drawXPosition >= SCREEN_WIDTH) createSpectrogramRow();

      const ctx = spectrogramRows[spectrogramRows.length - 1].ctx;
      for (let i = 0; i < audioAnalyzer.frequencyBinCount; i++) {
        ctx.fillStyle = `hsl(${audioDataArray[i] * 1.5},100%,50%)`;
        ctx.fillRect(drawXPosition, USEFUL_CANVAS_HEIGHT - i, 1, 1);
      }

      const elapsedSec = Math.floor(generateAudio.currentTime);
      if (elapsedSec % 60 === 0) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = (elapsedSec % 900 === 0 ? 2 : 1);
        ctx.beginPath();
        ctx.moveTo(drawXPosition + .5, USEFUL_CANVAS_HEIGHT);
        ctx.lineTo(drawXPosition + .5, USEFUL_CANVAS_HEIGHT + MINUTE_TICK_HEIGHT);
        ctx.stroke();
      }

      if (drawXPosition % PIXEL_LABEL_INTERVAL === 0) {
        const lbl = formatTime(tCurrent);
        const w = ctx.measureText(lbl).width;
        ctx.fillStyle = '#000';
        ctx.fillRect(drawXPosition - w/2 - LABEL_PADDING, USEFUL_CANVAS_HEIGHT + MINUTE_TICK_HEIGHT, w + LABEL_PADDING * 2, LABEL_AREA_HEIGHT);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.font = '12px sans-serif';
        ctx.fillText(lbl, drawXPosition, USEFUL_CANVAS_HEIGHT + MINUTE_TICK_HEIGHT + 2);
      }

      drawXPosition++;
      updateGenerateDisplay();
      generateAnimationFrame = requestAnimationFrame(drawSpectrogramFrame);
    }

    // Phase 2 setup: new audio & overlay click handling
    function setupPlaybackPhase() {
      if (!hasSpectrogramFinished) return;
      if (playbackAudio) playbackAudio.pause();

      playbackAudio = new Audio(URL.createObjectURL(fileInput.files[0]));
      playbackAudio.crossOrigin = 'anonymous';
      playbackAudio.preload = 'auto';
      playbackAudio.playbackRate = 1;

      overlayRows.forEach(({ canvas }, i) => {
        canvas.style.pointerEvents = 'auto';
        canvas.addEventListener('click', e => {
          const rect = canvas.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const startT = rowTimestamps[i];
          const endT = rowTimestamps[i+1] ?? playbackAudio.duration;
          const seekT = startT + (clickX / SCREEN_WIDTH)*(endT - startT);
          playbackAudio.currentTime = seekT;
          playbackAudio.play().catch(_ => { playbackAudio.load(); playbackAudio.play(); });
          drawPlaybackCursor();
        });
      });

      playerControls.style.display = '';

      playbackAudio.addEventListener('play', () => { isPlaybackPlaying = true; playPauseButton.textContent = 'Pause'; });
      playbackAudio.addEventListener('pause', () => { isPlaybackPlaying = false; playPauseButton.textContent = 'Play'; });
      playbackAudio.addEventListener('ended', () => { isPlaybackPlaying = false; playPauseButton.textContent = 'Play'; });
      playbackAudio.addEventListener('timeupdate', () => {
        const t = playbackAudio.currentTime;
        timeStatus.textContent = `Playback: ${formatTime(t)} / ${formatTime(playbackAudio.duration)}`;
        drawPlaybackCursor();
      });
    }

    function drawPlaybackCursor() {
      const t = playbackAudio.currentTime;
      overlayRows.forEach(({ ctx }, i) => {
        ctx.clearRect(0,0,SCREEN_WIDTH, ROW_HEIGHT);
        const t0 = rowTimestamps[i];
        const t1 = rowTimestamps[i+1] ?? playbackAudio.duration;
        if (t < t0 || t > t1) return;
        const x = (t - t0) / (t1 - t0) * SCREEN_WIDTH;
        ctx.lineWidth = 5; ctx.strokeStyle = 'red';
        ctx.beginPath(); ctx.moveTo(x+.5,0); ctx.lineTo(x+.5,ROW_HEIGHT); ctx.stroke();
        ctx.lineWidth = 3; ctx.strokeStyle = 'white';
        ctx.beginPath(); ctx.moveTo(x+.5,0); ctx.lineTo(x+.5,ROW_HEIGHT); ctx.stroke();
        ctx.lineWidth = 1; ctx.strokeStyle = 'black';
        ctx.beginPath(); ctx.moveTo(x+.5,0); ctx.lineTo(x+.5,ROW_HEIGHT); ctx.stroke();
      });
    }

    // Playback controls: 15s jump + play/pause
    rewind15Seconds.onclick = () => {
      if (!playbackAudio) return;
      playbackAudio.currentTime = Math.max(0, playbackAudio.currentTime - 15);
      drawPlaybackCursor();
    };
    forward15Seconds.onclick = () => {
      if (!playbackAudio) return;
      playbackAudio.currentTime = Math.min(playbackAudio.duration, playbackAudio.currentTime + 15);
      drawPlaybackCursor();
    };
    playPauseButton.onclick = () => {
      if (!playbackAudio) return;
      if (isPlaybackPlaying) playbackAudio.pause();
      else playbackAudio.play().catch(_ => { playbackAudio.load(); playbackAudio.play(); });
    };

    // Phase 1 controls: start/pause
    startGenerateButton.onclick = () => {
      if (!fileInput.files[0]) return alert('Please select an MP3 file.');
      if (generateAudio) generateAudio.pause();

      generateAudio = new Audio(URL.createObjectURL(fileInput.files[0]));
      generateAudio.crossOrigin = 'anonymous';
      generateAudio.playbackRate = Number(playbackSpeedSelect.value);
      const audioContext = new AudioContext();
      audioAnalyzer = audioContext.createAnalyser();
      const srcNode = audioContext.createMediaElementSource(generateAudio);
      srcNode.connect(audioAnalyzer);
      audioAnalyzer.connect(audioContext.destination);
      audioDataArray = new Uint8Array(audioAnalyzer.frequencyBinCount);

      drawXPosition = 0;
      hasSpectrogramFinished = false;
      isGeneratePaused = false;

      rowsContainer.innerHTML = '';
      spectrogramRows.length = 0;
      overlayRows.length = 0;
      rowTimestamps.length = 0;

      createSpectrogramRow();
      generateAudio.play().catch(console.error);
      pauseGenerateButton.disabled = false;
      drawSpectrogramFrame();
    };

    pauseGenerateButton.onclick = () => {
      if (!generateAudio) return;
      if (isGeneratePaused) {
        generateAudio.play(); isGeneratePaused = false;
        drawSpectrogramFrame();
      } else {
        generateAudio.pause(); isGeneratePaused = true;
        cancelAnimationFrame(generateAnimationFrame);
      }
    };

    // Show file duration once loaded
    fileInput.onchange = () => {
      if (!fileInput.files[0]) {
        timeStatus.textContent = 'No file selected.'; fileDurationStatus.textContent = '';
        return;
      }
      const tmpAudio = new Audio(URL.createObjectURL(fileInput.files[0]));
      tmpAudio.addEventListener('loadedmetadata', () => {
        fileDurationStatus.textContent = `Total Duration: ${formatTime(tmpAudio.duration)}`;
      });
    };

    // Export placeholder
    exportButton.onclick = () => alert('Export not implemented yet.');

  </script>
</body>
</html>
