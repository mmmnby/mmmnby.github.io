<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spectrogram Player (Complete)</title>
  <style>
    body { background: #111; color: #fff; font-family: sans-serif; margin: 0; text-align: center; }
    .controls { padding: 10px; }
    .controls > * { margin: 6px; font-size: 16px; }
    #timeStatus { margin-top: 6px; font-size: 14px; font-style: italic; }
    .canvasRowContainer { position: relative; display: inline-block; margin-bottom: 20px; }
    canvas.spectrogramCanvas { background: #000; display: block; }
    canvas.cursorOverlayCanvas { position: absolute; left: 0; top: 0; pointer-events: auto; }
    #playerControls { margin: 10px; display: none; }
    #playerControls button { margin: 0 6px; font-size: 16px; padding: 6px 12px; }
  </style>
</head>
<body>

  <h1>Spectrogram Player (Complete)</h1>

  <div class="controls">
    <input type="file" id="fileInput" accept=".mp3">
    <label> Speed:
      <select id="playbackSpeedSelect">
        <option>1</option><option>2</option><option>4</option>
        <option>30</option><option>60</option><option>120</option>
      </select> ×
    </label>
    <button id="startGenerateButton">Play (Phase 1)</button>
    <button id="pauseGenerateButton" disabled>Pause</button>
    <button id="exportButton">Download Spectrogram</button>
    <div id="timeStatus">No file loaded.</div>
    <div id="fileDurationStatus"></div>
  </div>

  <div id="rowsContainer"></div>

  <div id="playerControls">
    <button id="rewind15Seconds">◀ 15 s</button>
    <button id="playPauseButton">Play/Pause</button>
    <button id="forward15Seconds">15 s ▶</button>
  </div>

<script>
  const SCREEN_WIDTH = window.innerWidth;
  const ROW_HEIGHT = 300;
  const MINUTE_TICK_HEIGHT = 10;
  const LABEL_AREA_HEIGHT = 20;
  const USEFUL_CANVAS_HEIGHT = ROW_HEIGHT - MINUTE_TICK_HEIGHT - LABEL_AREA_HEIGHT;
  const PIXEL_LABEL_INTERVAL = 100;
  const LABEL_PADDING = 6;

  const fileInput = document.getElementById('fileInput');
  const playbackSpeedSelect = document.getElementById('playbackSpeedSelect');
  const startGenerateButton = document.getElementById('startGenerateButton');
  const pauseGenerateButton = document.getElementById('pauseGenerateButton');
  const exportButton = document.getElementById('exportButton');
  const timeStatus = document.getElementById('timeStatus');
  const fileDurationStatus = document.getElementById('fileDurationStatus');
  const rowsContainer = document.getElementById('rowsContainer');
  const playerControls = document.getElementById('playerControls');
  const rewind15Seconds = document.getElementById('rewind15Seconds');
  const playPauseButton = document.getElementById('playPauseButton');
  const forward15Seconds = document.getElementById('forward15Seconds');

  let generatePhaseAudio = null;
  let audioAnalyzer = null;
  let audioDataArray = null;
  let drawXPosition = 0;
  let finalRowWidth = 0;
  let hasFinishedSpectrogram = false;
  let generatePhasePaused = false;
  let generatePhaseAnimationId = null;
  let audioContext = null;

  const spectrogramRows = [];
  const cursorOverlayRows = [];
  const rowStartTimeMarkers = [];

  let playbackPhaseAudio = null;
  let playbackPhasePlaying = false;

  function formatTime(totalSeconds) {
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = Math.floor(totalSeconds % 60);
    return `${hours}h${minutes}m${seconds}s`;
  }

  function updateTimeStatus() {
    if (!generatePhaseAudio) {
      timeStatus.textContent = 'No file loaded.';
      return;
    }
    const currentTime = generatePhaseAudio.currentTime;
    const duration = generatePhaseAudio.duration || 0;
    timeStatus.textContent = `Processing: ${formatTime(currentTime)} / ${formatTime(duration)}`;
  }

  function createSpectrogramRow() {
    const rowContainer = document.createElement('div');
    rowContainer.className = 'canvasRowContainer';

    const spectrogramCanvas = document.createElement('canvas');
    spectrogramCanvas.width = SCREEN_WIDTH;
    spectrogramCanvas.height = ROW_HEIGHT;
    spectrogramCanvas.className = 'spectrogramCanvas';
    const spectrogramCanvasRenderingContext = spectrogramCanvas.getContext('2d');
    spectrogramCanvasRenderingContext.fillStyle = '#000';
    spectrogramCanvasRenderingContext.fillRect(0, 0, SCREEN_WIDTH, ROW_HEIGHT);
    rowContainer.appendChild(spectrogramCanvas);
    spectrogramRows.push({ canvas: spectrogramCanvas, canvasRenderingContext: spectrogramCanvasRenderingContext });

    const overlayCanvas = document.createElement('canvas');
    overlayCanvas.width = SCREEN_WIDTH;
    overlayCanvas.height = ROW_HEIGHT;
    overlayCanvas.className = 'cursorOverlayCanvas';
    const overlayCanvasRenderingContext = overlayCanvas.getContext('2d');
    rowContainer.appendChild(overlayCanvas);
    cursorOverlayRows.push({ canvas: overlayCanvas, canvasRenderingContext: overlayCanvasRenderingContext });

    rowStartTimeMarkers.push(generatePhaseAudio.currentTime);
    rowsContainer.appendChild(rowContainer);
    drawXPosition = 0;
  }

  function drawSpectrogramFrame() {
    if (generatePhaseAudio.paused || generatePhasePaused) return;

    audioAnalyzer.getByteFrequencyData(audioDataArray);
    if (drawXPosition >= SCREEN_WIDTH) createSpectrogramRow();

    const currentSpectrogramRow = spectrogramRows[spectrogramRows.length - 1];
    const canvasRenderingContext = currentSpectrogramRow.canvasRenderingContext;

    for (let i = 0; i < audioAnalyzer.frequencyBinCount; i++) {
      const value = audioDataArray[i];
      canvasRenderingContext.fillStyle = `hsl(${value * 1.5},100%,50%)`;
      canvasRenderingContext.fillRect(drawXPosition, USEFUL_CANVAS_HEIGHT - i, 1, 1);
    }

    const elapsedSeconds = Math.floor(generatePhaseAudio.currentTime);
    if (elapsedSeconds % 60 === 0) {
      canvasRenderingContext.strokeStyle = '#fff';
      canvasRenderingContext.lineWidth = (elapsedSeconds % 900 === 0 ? 2 : 1);
      canvasRenderingContext.beginPath();
      canvasRenderingContext.moveTo(drawXPosition + 0.5, USEFUL_CANVAS_HEIGHT);
      canvasRenderingContext.lineTo(drawXPosition + 0.5, USEFUL_CANVAS_HEIGHT + MINUTE_TICK_HEIGHT);
      canvasRenderingContext.stroke();
    }

    if (drawXPosition % PIXEL_LABEL_INTERVAL === 0) {
      const label = formatTime(generatePhaseAudio.currentTime);
      const textWidth = canvasRenderingContext.measureText(label).width;
      canvasRenderingContext.fillStyle = '#000';
      canvasRenderingContext.fillRect(drawXPosition - textWidth / 2 - LABEL_PADDING, USEFUL_CANVAS_HEIGHT + MINUTE_TICK_HEIGHT, textWidth + 2 * LABEL_PADDING, LABEL_AREA_HEIGHT);
      canvasRenderingContext.fillStyle = '#fff';
      canvasRenderingContext.textAlign = 'center';
      canvasRenderingContext.textBaseline = 'top';
      canvasRenderingContext.font = '12px sans-serif';
      canvasRenderingContext.fillText(label, drawXPosition, USEFUL_CANVAS_HEIGHT + MINUTE_TICK_HEIGHT + 2);
    }

    drawXPosition++;
    updateTimeStatus();
    generatePhaseAnimationId = requestAnimationFrame(drawSpectrogramFrame);

    if (generatePhaseAudio.ended || generatePhaseAudio.currentTime >= generatePhaseAudio.duration) {
      handleSpectrogramCompletion();
      return;
    }
  }

  function handleSpectrogramCompletion() {
    if (hasFinishedSpectrogram) return;
    cancelAnimationFrame(generatePhaseAnimationId);
    finalRowWidth = drawXPosition;
    hasFinishedSpectrogram = true;
    playerControls.style.display = 'block';
    startGenerateButton.disabled = true;
    pauseGenerateButton.disabled = true;
    setupPlaybackPhase();
  }

  function setupPlaybackPhase() {
    if (!hasFinishedSpectrogram) return;
    if (playbackPhaseAudio) {
      playbackPhaseAudio.pause();
      playbackPhaseAudio = null;
    }

    playbackPhaseAudio = new Audio(URL.createObjectURL(fileInput.files[0]));
    playbackPhaseAudio.crossOrigin = 'anonymous';
    playbackPhaseAudio.preload = 'auto';
    playbackPhaseAudio.playbackRate = 1.0;
    playbackPhasePlaying = false;

    cursorOverlayRows.forEach(({ canvas, canvasRenderingContext }, index) => {
      canvas.style.pointerEvents = 'auto';
      canvas.addEventListener('click', event => {
        if (!playbackPhaseAudio) return;
        const boundingRect = canvas.getBoundingClientRect();
        const clickX = event.clientX - boundingRect.left;
        const rowStartTime = rowStartTimeMarkers[index];
        const rowEndTime = rowStartTimeMarkers[index + 1] || playbackPhaseAudio.duration;
        const seekTime = rowStartTime + (clickX / SCREEN_WIDTH) * (rowEndTime - rowStartTime);
        playbackPhaseAudio.currentTime = seekTime;
        playbackPhaseAudio.play().catch(() => {
          playbackPhaseAudio.load();
          playbackPhaseAudio.play();
        });
        drawPlaybackCursor();
      });
    });

    playerControls.style.display = 'block';
    playbackPhaseAudio.addEventListener('play', () => {
      playbackPhasePlaying = true;
      playPauseButton.textContent = 'Pause';
    });
    playbackPhaseAudio.addEventListener('pause', () => {
      playbackPhasePlaying = false;
      playPauseButton.textContent = 'Play';
    });
    playbackPhaseAudio.addEventListener('ended', () => {
      playbackPhasePlaying = false;
      playPauseButton.textContent = 'Play';
    });
    playbackPhaseAudio.addEventListener('timeupdate', () => {
      const currentTimeInSeconds = playbackPhaseAudio.currentTime;
      timeStatus.textContent = `Playback: ${formatTime(currentTimeInSeconds)} / ${formatTime(playbackPhaseAudio.duration)}`;
      drawPlaybackCursor();
    });
  }

  function drawPlaybackCursor() {
    if (!playbackPhaseAudio) return;
    const currentTimeInSeconds = playbackPhaseAudio.currentTime;

    cursorOverlayRows.forEach(({ canvas, canvasRenderingContext }, index) => {
      canvasRenderingContext.clearRect(0, 0, SCREEN_WIDTH, ROW_HEIGHT);
      const rowStartTime = rowStartTimeMarkers[index];
      const rowEndTime = rowStartTimeMarkers[index + 1] || playbackPhaseAudio.duration;
      if (currentTimeInSeconds < rowStartTime || currentTimeInSeconds > rowEndTime) return;
      const cursorX = (currentTimeInSeconds - rowStartTime) / (rowEndTime - rowStartTime) * SCREEN_WIDTH;
      canvasRenderingContext.lineWidth = 5;
      canvasRenderingContext.strokeStyle = 'red';
      canvasRenderingContext.beginPath();
      canvasRenderingContext.moveTo(cursorX + 0.5, 0);
      canvasRenderingContext.lineTo(cursorX + 0.5, ROW_HEIGHT);
      canvasRenderingContext.stroke();
      canvasRenderingContext.lineWidth = 3;
      canvasRenderingContext.strokeStyle = 'white';
      canvasRenderingContext.beginPath();
      canvasRenderingContext.moveTo(cursorX + 0.5, 0);
      canvasRenderingContext.lineTo(cursorX + 0.5, ROW_HEIGHT);
      canvasRenderingContext.stroke();
      canvasRenderingContext.lineWidth = 1;
      canvasRenderingContext.strokeStyle = 'black';
      canvasRenderingContext.beginPath();
      canvasRenderingContext.moveTo(cursorX + 0.5, 0);
      canvasRenderingContext.lineTo(cursorX + 0.5, ROW_HEIGHT);
      canvasRenderingContext.stroke();
    });
  }

  // ... [No changes below this line]
</script>

</body>
</html>
