<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spectrogram Player (Verbose & Commented)</title>
  <style>
    body { background: #111; color: #fff; font-family: sans-serif; margin: 0; text-align: center; }
    .controls { padding: 10px; }
    .controls > * { margin: 6px; font-size: 16px; }
    #timeStatus { margin-top: 6px; font-size: 14px; font-style: italic; }
    .canvasRowContainer { position: relative; display: inline-block; margin-bottom: 20px; }
    canvas.spectrogramCanvas { background: #000; display: block; }
    canvas.cursorOverlayCanvas {
      position: absolute; left: 0; top: 0;
      pointer-events: auto;
    }
    #playerControls { margin: 10px; display: none; }
    #playerControls button { margin: 0 6px; font-size: 16px; padding: 6px 12px; }
  </style>
</head>
<body>

  <h1>Spectrogram Player (Verbose Version)</h1>

  <div class="controls">
    <input type="file" id="fileInput" accept=".mp3">
    <label> Speed:
      <select id="playbackSpeedSelect">
        <option>1</option><option>2</option><option>4</option>
        <option>30</option><option>60</option><option>120</option>
      </select> ×
    </label>
    <button id="startGenerateButton">Play (Phase 1)</button>
    <button id="pauseGenerateButton" disabled>Pause</button>
    <button id="exportButton">Download Spectrogram</button>

    <div id="timeStatus">No file loaded.</div>
    <div id="fileDurationStatus"></div>
  </div>

  <div id="rowsContainer"></div>

  <div id="playerControls">
    <button id="rewind15Seconds">◀ 15 s</button>
    <button id="playPauseButton">Play/Pause</button>
    <button id="forward15Seconds">15 s ▶</button>
  </div>

  <script>
    // ----- Configuration Constants -----
    const SCREEN_WIDTH = window.innerWidth;
    const ROW_HEIGHT = 300;
    const MINUTE_TICK_HEIGHT = 10;
    const LABEL_AREA_HEIGHT = 20;
    const USEFUL_CANVAS_HEIGHT = ROW_HEIGHT - MINUTE_TICK_HEIGHT - LABEL_AREA_HEIGHT;
    const PIXEL_INTERVAL_BETWEEN_LABELS = 100;
    const LABEL_HORIZONTAL_PADDING = 6;

    // ----- Track DOM Elements -----
    const fileInput = document.getElementById('fileInput');
    const playbackSpeedSelect = document.getElementById('playbackSpeedSelect');
    const startGenerateButton = document.getElementById('startGenerateButton');
    const pauseGenerateButton = document.getElementById('pauseGenerateButton');
    const exportButton = document.getElementById('exportButton');
    const timeStatus = document.getElementById('timeStatus');
    const fileDurationStatus = document.getElementById('fileDurationStatus');
    const rowsContainer = document.getElementById('rowsContainer');
    const playerControls = document.getElementById('playerControls');
    const rewind15Seconds = document.getElementById('rewind15Seconds');
    const playPauseButton = document.getElementById('playPauseButton');
    const forward15Seconds = document.getElementById('forward15Seconds');

    // ----- Application State Variables -----
    let generatePhaseAudio, audioAnalyzer, audioDataArray;
    let drawingPixelPosition = 0;
    let hasFinishedSpectrogram = false;
    let isGeneratePhasePaused = false;
    let generatePhaseAnimationId = null;

    const spectrogramRows = [];          // Stores canvas & context for each generated row
    const cursorOverlayRows = [];        // Stores overlay canvas & context for each row
    const rowStartTimeMarkers = [];      // Stores audio timestamp when each row began

    let playbackPhaseAudio = null;
    let isPlaybackPhasePlaying = false;

    // ===== Utility: Format seconds to HhMmSs =====
    function formatSecondsToHhMmSs(totalSeconds) {
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = Math.floor(totalSeconds % 60);
      return `${hours}h${minutes}m${seconds}s`;
    }

    // ===== PHASE 1: Generate spectrogram rows =====
    function updateGeneratePhaseDisplay() {
      if (generatePhaseAudio) {
        const elapsed = generatePhaseAudio.currentTime;
        const totalDuration = generatePhaseAudio.duration || 0;
        timeStatus.textContent = 
          `Processing: ${formatSecondsToHhMmSs(elapsed)} / ${formatSecondsToHhMmSs(totalDuration)}`;
      } else {
        timeStatus.textContent = 'No file loaded.';
      }
    }

    function createNewSpectrogramRow() {
      const containerDiv = document.createElement('div');
      containerDiv.className = 'canvasRowContainer';

      const spectroCanvas = document.createElement('canvas');
      spectroCanvas.width = SCREEN_WIDTH;
      spectroCanvas.height = ROW_HEIGHT;
      spectroCanvas.className = 'spectrogramCanvas';
      const spectroContext = spectroCanvas.getContext('2d');
      spectroContext.fillStyle = '#000';
      spectroContext.fillRect(0, 0, SCREEN_WIDTH, ROW_HEIGHT);
      containerDiv.appendChild(spectroCanvas);
      spectrogramRows.push({ canvas: spectroCanvas, context: spectroContext });

      const overlayCanvas = document.createElement('canvas');
      overlayCanvas.width = SCREEN_WIDTH;
      overlayCanvas.height = ROW_HEIGHT;
      overlayCanvas.className = 'cursorOverlayCanvas';
      const overlayContext = overlayCanvas.getContext('2d');
      containerDiv.appendChild(overlayCanvas);
      cursorOverlayRows.push({ canvas: overlayCanvas, context: overlayContext });

      // Record timestamp when this row began
      rowStartTimeMarkers.push(generatePhaseAudio.currentTime);

      rowsContainer.appendChild(containerDiv);
      drawingPixelPosition = 0;
    }

    function drawSpectrogramFrame() {
      if (!generatePhaseAudio || generatePhaseAudio.paused || generatePhaseAudio.ended || isGeneratePhasePaused) {
        return;
      }

      audioAnalyzer.getByteFrequencyData(audioDataArray);

      if (drawingPixelPosition >= SCREEN_WIDTH) {
        createNewSpectrogramRow();
      }

      const currentRow = spectrogramRows[spectrogramRows.length - 1];
      const context = currentRow.context;

      for (let freqIndex = 0; freqIndex < audioAnalyzer.frequencyBinCount; freqIndex++) {
        const intensity = audioDataArray[freqIndex];
        context.fillStyle = `hsl(${intensity * 1.5}, 100%, 50%)`;
        context.fillRect(drawingPixelPosition, USEFUL_CANVAS_HEIGHT - freqIndex, 1, 1);
      }

      const elapsedSeconds = Math.floor(generatePhaseAudio.currentTime);

      // Draw tick marks every minute, thicker every 15 minutes
      if (elapsedSeconds % 60 === 0) {
        context.strokeStyle = '#fff';
        context.lineWidth = (elapsedSeconds % 900 === 0 ? 2 : 1);
        context.beginPath();
        context.moveTo(drawingPixelPosition + 0.5, USEFUL_CANVAS_HEIGHT);
        context.lineTo(drawingPixelPosition + 0.5, USEFUL_CANVAS_HEIGHT + MINUTE_TICK_HEIGHT);
        context.stroke();
      }

      // Draw time label every 100px
      if (drawingPixelPosition % PIXEL_INTERVAL_BETWEEN_LABELS === 0) {
        const labelText = formatSecondsToHhMmSs(generatePhaseAudio.currentTime);
        const labelWidth = context.measureText(labelText).width;
        context.fillStyle = '#000';
        context.fillRect(
          drawingPixelPosition - labelWidth / 2 - LABEL_HORIZONTAL_PADDING,
          USEFUL_CANVAS_HEIGHT + MINUTE_TICK_HEIGHT,
          labelWidth + LABEL_HORIZONTAL_PADDING * 2,
          LABEL_AREA_HEIGHT
        );
        context.fillStyle = '#fff';
        context.textAlign = 'center';
        context.textBaseline = 'top';
        context.font = '12px sans-serif';
        context.fillText(labelText, drawingPixelPosition, USEFUL_CANVAS_HEIGHT + MINUTE_TICK_HEIGHT + 2);
      }

      drawingPixelPosition++;
      updateGeneratePhaseDisplay();
      generatePhaseAnimationId = requestAnimationFrame(drawSpectrogramFrame);

      if (generatePhaseAudio.ended) {
        finalizeLastSpectrogramRow();
      }
    }

    function finalizeLastSpectrogramRow() {
      cancelAnimationFrame(generatePhaseAnimationId);

      const lastRowContext = spectrogramRows[spectrogramRows.length - 1].context;
      const checkerSize = 6;
      for (let x = drawingPixelPosition; x < SCREEN_WIDTH; x += checkerSize) {
        for (let y = 0; y < USEFUL_CANVAS_HEIGHT; y += checkerSize) {
          const checkerColor = (((x / checkerSize) ^ (y / checkerSize)) % 2 === 0) ? '#444' : '#222';
          lastRowContext.fillStyle = checkerColor;
          lastRowContext.fillRect(x, y, checkerSize, checkerSize);
        }
      }

      hasFinishedSpectrogram = true;
      playerControls.style.display = 'block';
      generatePhaseAudio.currentTime = 0;
      setupPlaybackPhase();
    }

    // ===== PHASE 2: Playback, Cursor, and Controls =====
    function setupPlaybackPhase() {
      if (!hasFinishedSpectrogram) return;

      if (playbackPhaseAudio) {
        playbackPhaseAudio.pause();
        playbackPhaseAudio = null;
      }

      playbackPhaseAudio = new Audio(URL.createObjectURL(fileInput.files[0]));
      playbackPhaseAudio.crossOrigin = 'anonymous';
      playbackPhaseAudio.preload = 'auto';
      playbackPhaseAudio.playbackRate = 1.0;
      isPlaybackPhasePlaying = false;

      cursorOverlayRows.forEach((rowOverlay, rowIndex) => {
        const overlayCanvas = rowOverlay.canvas;
        overlayCanvas.style.pointerEvents = 'auto';

        overlayCanvas.addEventListener('click', event => {
          if (!playbackPhaseAudio) return;
          const boundingRect = overlayCanvas.getBoundingClientRect();
          const clickX = event.clientX - boundingRect.left;

          const startTime = rowStartTimeMarkers[rowIndex];
          const endTime = rowStartTimeMarkers[rowIndex + 1] || playbackPhaseAudio.duration;
          const chosenTime = startTime + (clickX / SCREEN_WIDTH) * (endTime - startTime);

          playbackPhaseAudio.currentTime = chosenTime;
          playbackPhaseAudio.play().catch(err => {
            playbackPhaseAudio.load();
            playbackPhaseAudio.play();
          });
          drawPlaybackCursor();
        });
      });

      playerControls.style.display = 'block';

      playbackPhaseAudio.addEventListener('play', () => {
        isPlaybackPhasePlaying = true;
        playPauseButton.textContent = 'Pause';
      });

      playbackPhaseAudio.addEventListener('pause', () => {
        isPlaybackPhasePlaying = false;
        playPauseButton.textContent = 'Play';
      });

      playbackPhaseAudio.addEventListener('ended', () => {
        isPlaybackPhasePlaying = false;
        playPauseButton.textContent = 'Play';
      });

      playbackPhaseAudio.addEventListener('timeupdate', () => {
        displayPlaybackTime();
        drawPlaybackCursor();
      });
    }

    function displayPlaybackTime() {
      if (!playbackPhaseAudio) return;
      timeStatus.textContent = `Playback: ${formatSecondsToHhMmSs(playbackPhaseAudio.currentTime)} / ${formatSecondsToHhMmSs(playbackPhaseAudio.duration)}`;
    }

    function drawPlaybackCursor() {
      if (!playbackPhaseAudio) return;

      const currentTime = playbackPhaseAudio.currentTime;

      cursorOverlayRows.forEach((rowOverlay, rowIndex) => {
        const { context } = rowOverlay;
        context.clearRect(0, 0, SCREEN_WIDTH, ROW_HEIGHT);

        const rowStartTime = rowStartTimeMarkers[rowIndex];
        const nextRowStartTime = rowStartTimeMarkers[rowIndex + 1] || playbackPhaseAudio.duration;
        if (currentTime < rowStartTime || currentTime > nextRowStartTime) return;

        const positionPercentage = (currentTime - rowStartTime) / (nextRowStartTime - rowStartTime);
        const cursorX = positionPercentage * SCREEN_WIDTH;

        // Outer red border
        context.lineWidth = 5;
        context.strokeStyle = 'red';
        context.beginPath();
        context.moveTo(cursorX + 0.5, 0);
        context.lineTo(cursorX + 0.5, ROW_HEIGHT);
        context.stroke();

        // Middle white border
        context.lineWidth = 3;
        context.strokeStyle = 'white';
        context.beginPath();
        context.moveTo(cursorX + 0.5, 0);
        context.lineTo(cursorX + 0.5, ROW_HEIGHT);
        context.stroke();

        // Thin black center line
        context.lineWidth = 1;
        context.strokeStyle = 'black';
        context.beginPath();
        context.moveTo(cursorX + 0.5, 0);
        context.lineTo(cursorX + 0.5, ROW_HEIGHT);
        context.stroke();
      });
    }

    // ===== Button event handlers =====
    rewind15Seconds.addEventListener('click', () => {
      if (!playbackPhaseAudio) return;
      playbackPhaseAudio.currentTime = Math.max(0, playbackPhaseAudio.currentTime - 15);
      drawPlaybackCursor();
    });

    forward15Seconds.addEventListener('click', () => {
      if (!playbackPhaseAudio) return;
      playbackPhaseAudio.currentTime = Math.min(playbackPhaseAudio.duration, playbackPhaseAudio.currentTime + 15);
      drawPlaybackCursor();
    });

    playPauseButton.addEventListener('click', () => {
      if (!playbackPhaseAudio) return;
      if (isPlaybackPhasePlaying) {
        playbackPhaseAudio.pause();
      } else {
        playbackPhaseAudio.play().catch(err => {
          playbackPhaseAudio.load();
          playbackPhaseAudio.play();
        });
      }
    });

    // ===== Phase 1 start/pause/resize =====
    startGenerateButton.addEventListener('click', () => {
      if (!fileInput.files[0]) return alert('Please choose an MP3 file first.');

      if (generatePhaseAudio) {
        generatePhaseAudio.pause();
        generatePhaseAudio = null;
      }

      generatePhaseAudio = new Audio(URL.createObjectURL(fileInput.files[0]));
      generatePhaseAudio.crossOrigin = 'anonymous';
      generatePhaseAudio.playbackRate = Number(playbackSpeedSelect.value);

      const audioContext = new AudioContext();
      audioAnalyzer = audioContext.createAnalyser();
      const sourceNode = audioContext.createMediaElementSource(generatePhaseAudio);
      sourceNode.connect(audioAnalyzer);
      audioAnalyzer.connect(audioContext.destination);
      audioDataArray = new Uint8Array(audioAnalyzer.frequencyBinCount);

      hasFinishedSpectrogram = false;
      drawingPixelPosition = 0;
      rowsContainer.innerHTML = '';
      spectrogramRows.length = 0;
      cursorOverlayRows.length = 0;
      rowStartTimeMarkers.length = 0;

      createNewSpectrogramRow();

      generatePhaseAudio.play().catch(console.error);
      isGeneratePhasePaused = false;
      pauseGenerateButton.disabled = false;

      generatePhaseAudio.addEventListener('ended', () => {
        // completion is handled inside draw loop
      });

      drawSpectrogramFrame();
    });

    pauseGenerateButton.addEventListener('click', () => {
      if (!generatePhaseAudio) return;
      if (isGeneratePhasePaused) {
        generatePhaseAudio.play();
        isGeneratePhasePaused = false;
        drawSpectrogramFrame();
      } else {
        generatePhaseAudio.pause();
        isGeneratePhasePaused = true;
        cancelAnimationFrame(generatePhaseAnimationId);
      }
    });

    exportButton.addEventListener('click', () => {
      alert('Download not implemented in this version.');
    });

    // Display file duration on load
    fileInput.addEventListener('change', () => {
      if (!fileInput.files[0]) {
        timeStatus.textContent = 'No file loaded.';
        fileDurationStatus.textContent = '';
        return;
      }
      const tempAudio = document.createElement('audio');
      tempAudio.src = URL.createObjectURL(fileInput.files[0]);
      tempAudio.addEventListener('loadedmetadata', () => {
        fileDurationStatus.textContent = 
          'Total Duration: ' + formatSecondsToHhMmSs(tempAudio.duration);
      });
    });
  </script>
</body>
</html>
