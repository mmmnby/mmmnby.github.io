<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spectrogram Viewer</title>
  <style>
    body {
      background: black;
      color: white;
      font-family: sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }

    #fileInput {
      margin: 20px;
    }

    #canvasContainer {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .spectroCanvas {
      display: block;
    }

    #navButtons {
      display: none;
      margin-top: 20px;
    }

    .navBtn {
      margin: 0 10px;
      font-size: 20px;
      padding: 10px 20px;
    }

    #currentTimeDisplay {
      margin-top: 10px;
      font-size: 16px;
    }
  </style>
</head>
<body>

  <input type="file" id="fileInput" accept="audio/mpeg">
  <div id="canvasContainer"></div>
  <div id="currentTimeDisplay"></div>

  <div id="navButtons">
    <button class="navBtn" id="rewindBtn">←15s</button>
    <button class="navBtn" id="playPauseBtn">Play</button>
    <button class="navBtn" id="forwardBtn">→15s</button>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const canvasContainer = document.getElementById('canvasContainer');
    const navButtons = document.getElementById('navButtons');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const currentTimeDisplay = document.getElementById('currentTimeDisplay');

    let audio = new Audio();
    let audioCtx;
    let sourceNode;
    let analyser;
    let dataArray;
    let bufferLength;

    let canvasWidth = 800;
    let canvasHeight = 100;
    let usableHeight = canvasHeight;

    let drawX = 0;
    let drawStep = 2;
    let spectroCanvases = [];
    let animationId;
    let spectrogramComplete = false;

    fileInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const url = URL.createObjectURL(file);
      audio.src = url;
      await audio.play(); // Let it start to initialize

      setupAudio();
      createCanvasRow();
      drawSpectrogram();
    });

    function setupAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaElementSource(audio);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array(bufferLength);

      sourceNode.connect(analyser);
      analyser.connect(audioCtx.destination);
    }

    function createCanvasRow() {
      const canvas = document.createElement('canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      canvas.className = 'spectroCanvas';
      canvasContainer.appendChild(canvas);

      const ctx = canvas.getContext('2d');

      spectroCanvases.push({ canvas, ctx });
    }

    function drawSpectrogram() {
      animationId = requestAnimationFrame(drawSpectrogram);

      if (audio.paused || audio.ended) return;

      analyser.getByteFrequencyData(dataArray);

      const currentCanvas = spectroCanvases[spectroCanvases.length - 1];
      const ctx = currentCanvas.ctx;

      for (let y = 0; y < usableHeight; y++) {
        const value = dataArray[y];
        ctx.fillStyle = `rgb(${value}, ${value}, ${value})`;
        ctx.fillRect(drawX, usableHeight - y, drawStep, 1);
      }

      drawX += drawStep;

      if (drawX >= canvasWidth) {
        drawX = 0;
        createCanvasRow();
      }

      // End detection
      if (audio.ended || audio.currentTime >= audio.duration) {
        cancelAnimationFrame(animationId);
        spectrogramComplete = true;

        // Fill remainder of last row with checkerboard if not complete
        const last = spectroCanvases[spectroCanvases.length - 1];
        if (drawX < canvasWidth) {
          const ctx = last.ctx;
          const squareSize = 6;

          for (let x = drawX; x < canvasWidth; x += squareSize) {
            for (let y = 0; y < usableHeight; y += squareSize) {
              const isLight = ((x / squareSize) ^ (y / squareSize)) % 2 === 0;
              ctx.fillStyle = isLight ? '#444' : '#222';
              ctx.fillRect(x, y, squareSize, squareSize);
            }
          }
        }

        navButtons.style.display = 'block';
        audio.currentTime = 0;
        setupPhase2();
      }
    }

    function setupPhase2() {
      currentTimeDisplay.textContent = formatTime(audio.currentTime);

      playPauseBtn.onclick = () => {
        if (audio.paused) {
          audio.play();
          playPauseBtn.textContent = 'Pause';
        } else {
          audio.pause();
          playPauseBtn.textContent = 'Play';
        }
      };

      rewindBtn.onclick = () => {
        audio.currentTime = Math.max(0, audio.currentTime - 15);
      };

      forwardBtn.onclick = () => {
        audio.currentTime = Math.min(audio.duration, audio.currentTime + 15);
      };

      setInterval(() => {
        if (!spectrogramComplete) return;
        currentTimeDisplay.textContent = formatTime(audio.currentTime);
      }, 100);
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    }
  </script>
</body>
</html>
