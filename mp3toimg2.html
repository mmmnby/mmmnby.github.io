<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Spectrogram Tool</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      text-align: center;
    }
    .controls { padding: 10px; }
    input, select, button { margin: 5px; padding: 6px 10px; font-size: 15px; }
    #info { margin: 10px; }
    .canvas-container { display: flex; flex-direction: column; align-items: center; }
    canvas { background: black; margin: 8px 0; display: block; }
    .scrub-controls { margin: 10px; display: none; }
    .scrub-controls button { margin: 0 5px; }
  </style>
</head>
<body>

  <h1>Advanced Spectrogram Tool</h1>

  <div class="controls">
    <input type="file" id="audioFile" accept=".mp3">
    <label>Speed:</label>
    <select id="speed">
      <option value="1">1×</option>
      <option value="2">2×</option>
      <option value="4">4×</option>
      <option value="30">30×</option>
      <option value="60">60×</option>
      <option value="120">120×</option>
    </select>
    <button id="startBtn">Start</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="saveBtn">Download PNG</button>
  </div>

  <div id="info"></div>
  <div id="currentTime">Processed: 0s</div>

  <div class="canvas-container" id="canvasContainer"></div>

  <div class="scrub-controls" id="scrubControls">
    <button id="back15">⏪ 15s</button>
    <button id="playPause">Play ⏵/❚❚</button>
    <button id="forward15">15s ⏩</button>
  </div>

  <script>
    const container = document.getElementById("canvasContainer");
    const audioFile = document.getElementById("audioFile");
    const startBtn = document.getElementById("startBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const saveBtn = document.getElementById("saveBtn");
    const speedSelect = document.getElementById("speed");
    const info = document.getElementById("info");
    const currentTimeDisplay = document.getElementById("currentTime");
    const scrubControls = document.getElementById("scrubControls");
    const back15 = document.getElementById("back15");
    const playPauseBtn = document.getElementById("playPause");
    const forward15 = document.getElementById("forward15");

    const canvasWidth = window.innerWidth;
    const canvasHeight = 300;
    const labelHeight = 20;
    const tickZone = 20;
    const usableHeight = canvasHeight - labelHeight - tickZone;
    const labelIntervalPx = 100;

    let audio, audioCtx, sourceNode, analyser, dataArray;
    let drawX = 0, isPaused = false, animationId;
    let currentCanvas, ctx;
    let fileDuration = 0;

    function formatTimeHMS(sec) {
      const hrs = Math.floor(sec / 3600), mins = Math.floor((sec % 3600) / 60), s = Math.floor(sec % 60);
      return hrs + "h" + mins + "m" + s + "s";
    }

    function createCanvas() {
      const c = document.createElement("canvas");
      c.width = canvasWidth;
      c.height = canvasHeight;
      const cctx = c.getContext("2d");
      cctx.fillStyle = "black";
      cctx.fillRect(0, 0, c.width, c.height);
      container.appendChild(c);
      drawX = 0;
      return { c, cctx };
    }

    function drawTicks(cctx, yBase) {
      const totalMin = Math.floor(fileDuration / 60);
      for (let m = 0; m <= totalMin; m++) {
        const x = m * labelIntervalPx;
        if (x > canvasWidth) break;
        if (m % 15 === 0) {
          cctx.fillStyle = "white";
          cctx.fillRect(x - 1, yBase, 2, tickZone);
        } else {
          cctx.fillStyle = "#888";
          cctx.fillRect(x, yBase + tickZone/2, 1, tickZone/2);
        }
      }
    }

    function advanceSpectrogram() {
      if (!audio || audio.paused || audio.ended || isPaused) return;

      analyser.getByteFrequencyData(dataArray);
      for (let y = 0; y < analyser.frequencyBinCount; y++) {
        const v = dataArray[y], hue = v * 1.5;
        ctx.fillStyle = `hsl(${hue},100%,50%)`;
        ctx.fillRect(drawX, usableHeight - y, 1, 1);
      }

      if (drawX % labelIntervalPx === 0) {
        const t = audio.currentTime;
        ctx.fillStyle = "black";
        ctx.fillRect(drawX - 50, canvasHeight - labelHeight, 100, labelHeight);
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.font = "14px sans-serif";
        ctx.fillText(formatTimeHMS(t), drawX, canvasHeight - 6);
      }

      drawX++;
      currentTimeDisplay.textContent = `Processed: ${formatTimeHMS(audio.currentTime)}`;

      if (drawX >= canvasWidth) {
        const next = createCanvas();
        currentCanvas = next.c; ctx = next.cctx;
        drawTicks(ctx, usableHeight);
        ctx.textBaseline = "top";
        drawTicks(ctx, usableHeight);
      }
      animationId = requestAnimationFrame(advanceSpectrogram);
    }

    audioFile.addEventListener("change", () => {
      const f = audioFile.files[0];
      if (f) {
        info.textContent = `Loaded: ${f.name}`;
        const tmp = document.createElement("audio");
        tmp.src = URL.createObjectURL(f);
        tmp.addEventListener("loadedmetadata", () => {
          fileDuration = tmp.duration;
          info.textContent = `File: ${f.name} – Duration: ${formatTimeHMS(fileDuration)}`;
          URL.revokeObjectURL(tmp.src);
        });
      }
    });

    startBtn.addEventListener("click", () => {
      const f = audioFile.files[0];
      if (!f) { alert("Select MP3"); return; }
      if (animationId) cancelAnimationFrame(animationId);
      if (audio) { audio.pause(); URL.revokeObjectURL(audio.src); }
      container.innerHTML = "";
      const cobj = createCanvas();
      currentCanvas = cobj.c; ctx = cobj.cctx;
      drawTicks(ctx, usableHeight);

      const blob = URL.createObjectURL(f);
      audio = new Audio(blob);
      audio.crossOrigin = "anonymous";
      audio.playbackRate = parseFloat(speedSelect.value);

      audioCtx = new (AudioContext || webkitAudioContext)();
      sourceNode = audioCtx.createMediaElementSource(audio);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 512;
      dataArray = new Uint8Array(analyser.frequencyBinCount);
      sourceNode.connect(analyser);
      analyser.connect(audioCtx.destination);

      pauseBtn.disabled = false;
      scrubControls.style.display = "none";
      currentTimeDisplay.textContent = "Processed: 0s";

      audio.play();
      isPaused = false;
      advanceSpectrogram();

      audio.addEventListener("ended", () => {
        cancelAnimationFrame(animationId);
        currentTimeDisplay.textContent = `Completed at ${formatTimeHMS(audio.currentTime)}`;
        scrubControls.style.display = "block";
      });
    });

    pauseBtn.addEventListener("click", () => {
      if (!audio) return;
      isPaused = !isPaused;
      if (isPaused) { audio.pause(); pauseBtn.textContent = "Resume"; }
      else { audio.play(); pauseBtn.textContent = "Pause"; advanceSpectrogram(); }
    });

    saveBtn.addEventListener("click", () => {
      const canvases = container.querySelectorAll("canvas");
      const fullH = canvases.length * canvasHeight;
      const fullC = document.createElement("canvas");
      fullC.width = canvasWidth; fullC.height = fullH;
      const fctx = fullC.getContext("2d");
      canvases.forEach((cx,i) => fctx.drawImage(cx,0,i*canvasHeight));
      const img = fullC.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = img; a.download = "spectrogram.png";
      a.click();
    });

    back15.onclick = () => {
      audio.currentTime = Math.max(0, audio.currentTime - 15);
    };
    forward15.onclick = () => {
      audio.currentTime = Math.min(fileDuration, audio.currentTime + 15);
    };
    playPauseBtn.onclick = () => {
      if (!audio) return;
      if (audio.paused) { audio.play(); playPauseBtn.textContent = "❚❚"; advanceSpectrogram(); }
      else { audio.pause(); playPauseBtn.textContent = "⏵"; }
    };
  </script>

</body>
</html>
