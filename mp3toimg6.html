<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spectrogram Player with Notation</title>
  <style>
    body { background: #111; color: #fff; font-family: sans-serif; margin: 0; text-align: center; }
    .controls { padding: 10px; }
    .controls > * { margin: 6px; font-size: 16px; }
    #timeStatus { margin-top: 6px; font-size: 14px; font-style: italic; }
    .canvasRowContainer { position: relative; display: inline-block; margin-bottom: 20px; }
    canvas.spectrogramCanvas { background: #000; display: block; }
    canvas.cursorOverlayCanvas { position: absolute; left: 0; top: 0; pointer-events: auto; }
    canvas.notationCanvas { display: block; margin-top: 2px; cursor: crosshair; }
    #playerControls { margin: 10px; display: none; }
    #playerControls button, #editModeToggle, #highlightColorPicker, #eraserButton { margin: 0 6px; font-size: 16px; padding: 6px 12px; }
  </style>
</head>
<body>

  <h1>Spectrogram Player with Notation</h1>

  <div class="controls">
    <input type="file" id="fileInput" accept=".mp3">
    <label>Speed:
      <select id="playbackSpeedSelect">
        <option>1</option><option>2</option><option>4</option>
        <option>30</option><option>60</option><option>120</option>
      </select> ×
    </label>
    <button id="startGenerateButton">Play (Phase 1)</button>
    <button id="pauseGenerateButton" disabled>Pause</button>
    <button id="exportButton">Download Spectrogram</button>
    <div id="timeStatus">No file loaded.</div>
    <div id="fileDurationStatus"></div>
    <div id="playerControls">
      <button id="rewind15Seconds">◀ 15 s</button>
      <button id="playPauseButton">Play/Pause</button>
      <button id="forward15Seconds">15 s ▶</button>
    </div>
    <div id="editControls" style="display:none; margin-top:10px;">
      <button id="editModeToggle">Switch to Edit Mode</button>
      <input type="color" id="highlightColorPicker" value="#ffff00">
      <button id="eraserButton">Eraser</button>
    </div>
  </div>

  <div id="rowsContainer"></div>

<script>
  // === Constants ===
  const SCREEN_WIDTH = window.innerWidth;
  const ROW_HEIGHT = 300;
  const MINUTE_TICK_HEIGHT = 10;
  const LABEL_AREA_HEIGHT = 20;
  const NOTATION_TRACK_HEIGHT = 20;
  const NOTATION_TRACK_MARGIN = 2;
  const HIGHLIGHT_RESOLUTION = 50; // px

  // === DOM Elements ===
  const fileInput = document.getElementById('fileInput');
  const playbackSpeedSelect = document.getElementById('playbackSpeedSelect');
  const startGenerateButton = document.getElementById('startGenerateButton');
  const pauseGenerateButton = document.getElementById('pauseGenerateButton');
  const exportButton = document.getElementById('exportButton');
  const timeStatus = document.getElementById('timeStatus');
  const fileDurationStatus = document.getElementById('fileDurationStatus');
  const rowsContainer = document.getElementById('rowsContainer');
  const playerControls = document.getElementById('playerControls');
  const rewind15Seconds = document.getElementById('rewind15Seconds');
  const playPauseButton = document.getElementById('playPauseButton');
  const forward15Seconds = document.getElementById('forward15Seconds');
  const editControls = document.getElementById('editControls');
  const editModeToggle = document.getElementById('editModeToggle');
  const highlightColorPicker = document.getElementById('highlightColorPicker');
  const eraserButton = document.getElementById('eraserButton');

  // === Audio / Drawing State ===
  let generatePhaseAudio = null;
  let audioAnalyzer = null;
  let audioFrequencyData = null;
  let drawXPosition = 0;
  let finalRowDrawWidth = 0;
  let spectrogramCompleted = false;
  let spectrogramAnimationId = null;
  let audioContext = null;

  // Phase arrays
  const spectrogramRows = [];
  const cursorOverlayRows = [];
  const notationContextRows = [];
  const rowStartTimeMarkers = [];

  // Playback
  let playbackPhaseAudio = null;
  let isPlayingBack = false;

  // Edit Mode
  let isEditMode = false;
  let currentHighlightColor = highlightColorPicker.value;
  
  // === Helpers ===
  function formatTime(seconds) {
    const h = Math.floor(seconds/3600);
    const m = Math.floor((seconds%3600)/60);
    const s = Math.floor(seconds%60);
    return `${h}h${m}m${s}s`;
  }

  function updateTimeStatus() {
    if (!generatePhaseAudio) {
      timeStatus.textContent = 'No file loaded.';
      return;
    }
    const current = generatePhaseAudio.currentTime;
    const duration = generatePhaseAudio.duration || 0;
    timeStatus.textContent = (spectrogramCompleted
      ? `Playback: ${formatTime(current)} / ${formatTime(duration)}`
      : `Processing: ${formatTime(current)} / ${formatTime(duration)}`);
  }

  // === Spectrogram Row Creation ===
  function createSpectrogramRow() {
    const containerDiv = document.createElement('div');
    containerDiv.className = 'canvasRowContainer';

    // Spectrogram canvas
    const spectroCanvas = document.createElement('canvas');
    spectroCanvas.width = SCREEN_WIDTH;
    spectroCanvas.height = ROW_HEIGHT;
    spectroCanvas.className = 'spectrogramCanvas';
    const spectroContext = spectroCanvas.getContext('2d');
    spectroContext.fillStyle = '#000';
    spectroContext.fillRect(0, 0, SCREEN_WIDTH, ROW_HEIGHT);
    containerDiv.appendChild(spectroCanvas);
    spectrogramRows.push({ canvas: spectroCanvas, context: spectroContext });

    // Cursor overlay canvas
    const overlayCanvas = document.createElement('canvas');
    overlayCanvas.width = SCREEN_WIDTH;
    overlayCanvas.height = ROW_HEIGHT;
    overlayCanvas.className = 'cursorOverlayCanvas';
    const overlayContext = overlayCanvas.getContext('2d');
    containerDiv.appendChild(overlayCanvas);
    cursorOverlayRows.push({ canvas: overlayCanvas, context: overlayContext });

    // Notation canvas
    const notationCanvas = document.createElement('canvas');
    notationCanvas.width = SCREEN_WIDTH;
    notationCanvas.height = NOTATION_TRACK_HEIGHT;
    notationCanvas.className = 'notationCanvas';
    const notationContext = notationCanvas.getContext('2d');
    // transparent background by default
    containerDiv.appendChild(notationCanvas);
    notationContextRows.push({ canvas: notationCanvas, context: notationContext, isDrawing: false });

    // Timestamp marker
    rowStartTimeMarkers.push(generatePhaseAudio.currentTime);
    rowsContainer.appendChild(containerDiv);

    // Attach event handlers for notation editing
    attachNotationEventHandlers(notationContextRows.length - 1);
    
    // Reset draw X for new row
    drawXPosition = 0;
  }

  // === Notation Event Handlers ===
  function attachNotationEventHandlers(rowIndex) {
    const { canvas, context } = notationContextRows[rowIndex];
    canvas.addEventListener('mousedown', event => {
      if (!isEditMode) return;
      notationContextRows[rowIndex].isDrawing = true;
      drawNotationBlock(rowIndex, event.offsetX);
    });
    canvas.addEventListener('mousemove', event => {
      if (!isEditMode || !notationContextRows[rowIndex].isDrawing) return;
      drawNotationBlock(rowIndex, event.offsetX);
    });
    canvas.addEventListener('mouseup', () => {
      notationContextRows[rowIndex].isDrawing = false;
    });
    canvas.addEventListener('mouseleave', () => {
      notationContextRows[rowIndex].isDrawing = false;
    });
  }

  function drawNotationBlock(rowIndex, xPosition) {
    const { context } = notationContextRows[rowIndex];
    const blockStart = Math.floor(xPosition / HIGHLIGHT_RESOLUTION) * HIGHLIGHT_RESOLUTION;
    if (currentHighlightColor === 'eraser') {
      context.clearRect(blockStart, 0, HIGHLIGHT_RESOLUTION, NOTATION_TRACK_HEIGHT);
    } else {
      context.fillStyle = currentHighlightColor;
      context.fillRect(blockStart, 0, HIGHLIGHT_RESOLUTION, NOTATION_TRACK_HEIGHT);
    }
  }

  // === Spectrogram Drawing Loop ===
  function drawSpectrogramFrame() {
    if (generatePhaseAudio.paused) return;
    audioAnalyzer.getByteFrequencyData(audioFrequencyData);

    if (drawXPosition >= SCREEN_WIDTH) createSpectrogramRow();

    const { context: spectroCtx } = spectrogramRows[spectrogramRows.length - 1];
    for (let i = 0; i < audioAnalyzer.frequencyBinCount; i++) {
      const value = audioFrequencyData[i];
      spectroCtx.fillStyle = `hsl(${value * 1.5},100%,50%)`;
      spectroCtx.fillRect(drawXPosition, ROW_HEIGHT - MINUTE_TICK_HEIGHT - LABEL_AREA_HEIGHT - i, 1, 1);
    }

    // Minute ticks
    const elapsedSeconds = Math.floor(generatePhaseAudio.currentTime);
    if (elapsedSeconds % 60 === 0) {
      spectroCtx.strokeStyle = '#fff';
      spectroCtx.lineWidth = (elapsedSeconds % 900 === 0 ? 24 : 8);
      spectroCtx.beginPath();
      spectroCtx.moveTo(drawXPosition + .5, ROW_HEIGHT - MINUTE_TICK_HEIGHT - LABEL_AREA_HEIGHT);
      spectroCtx.lineTo(drawXPosition + .5, ROW_HEIGHT - LABEL_AREA_HEIGHT);
      spectroCtx.stroke();
    }

    // Pixel labels every PIXEL_LABEL_INTERVAL
    if (drawXPosition % 100 === 0) {
      const label = formatTime(generatePhaseAudio.currentTime);
      const textWidth = spectroCtx.measureText(label).width;
      const labelX = drawXPosition - textWidth / 2;
      spectroCtx.fillStyle = '#000';
      spectroCtx.fillRect(labelX - 6, ROW_HEIGHT - LABEL_AREA_HEIGHT, textWidth + 12, LABEL_AREA_HEIGHT);
      spectroCtx.fillStyle = '#fff';
      spectroCtx.textAlign = 'center';
      spectroCtx.textBaseline = 'top';
      spectroCtx.font = '12px sans-serif';
      spectroCtx.fillText(label, drawXPosition, ROW_HEIGHT - LABEL_AREA_HEIGHT + 2);
    }

    drawXPosition++;
    updateTimeStatus();
    spectrogramAnimationId = requestAnimationFrame(drawSpectrogramFrame);

    const EPSILON = 0.05;
    if (!spectrogramCompleted && generatePhaseAudio.currentTime >= generatePhaseAudio.duration - EPSILON) {
      handleSpectrogramCompletion();
    }
  }

  // === Completion & Phase Switch ===
  function handleSpectrogramCompletion() {
    if (spectrogramCompleted) return;
    cancelAnimationFrame(spectrogramAnimationId);
    finalRowDrawWidth = drawXPosition;
    spectrogramCompleted = true;

    startGenerateButton.disabled = true;
    pauseGenerateButton.disabled = true;
    playerControls.style.display = 'block';
    editControls.style.display = 'block';

    timeStatus.textContent = 'Spectrogram complete. Ready for playback.';
    setupPlaybackPhase();
  }

  // === Playback Phase Setup ===
  function setupPlaybackPhase() {
    if (!spectrogramCompleted) return;
    if (playbackPhaseAudio) { playbackPhaseAudio.pause(); playbackPhaseAudio = null; }

    playbackPhaseAudio = new Audio(URL.createObjectURL(fileInput.files[0]));
    playbackPhaseAudio.crossOrigin = 'anonymous';
    playbackPhaseAudio.preload = 'auto';
    playbackPhaseAudio.playbackRate = 1.0;

    // Seek on overlayCanvas click (when not in edit mode)
    cursorOverlayRows.forEach(({ canvas }, rowIndex) => {
      canvas.addEventListener('click', event => {
        if (isEditMode) return;
        const rect = canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const isLastRow = rowIndex === rowStartTimeMarkers.length - 1;
        const rowWidth = isLastRow ? finalRowDrawWidth : SCREEN_WIDTH;
        const startTime = rowStartTimeMarkers[rowIndex];
        const endTime = rowStartTimeMarkers[rowIndex + 1] || playbackPhaseAudio.duration;
        const seekTime = startTime + (clickX / rowWidth) * (endTime - startTime);
        playbackPhaseAudio.currentTime = seekTime;
        playbackPhaseAudio.play();
        drawPlaybackCursor();
      });
    });

    playbackPhaseAudio.addEventListener('timeupdate', () => {
      updateTimeStatus();
      drawPlaybackCursor();
    });
  }

  function drawPlaybackCursor() {
    if (!playbackPhaseAudio) return;
    const currentTime = playbackPhaseAudio.currentTime;

    cursorOverlayRows.forEach(({ canvas, context }, rowIndex) => {
      context.clearRect(0, 0, SCREEN_WIDTH, ROW_HEIGHT);
      const startTime = rowStartTimeMarkers[rowIndex];
      const endTime = rowStartTimeMarkers[rowIndex + 1] || playbackPhaseAudio.duration;
      if (currentTime < startTime || currentTime > endTime) return;
      const isLastRow = rowIndex === rowStartTimeMarkers.length - 1;
      const rowWidth = isLastRow ? finalRowDrawWidth : SCREEN_WIDTH;
      const xPos = ((currentTime - startTime) / (endTime - startTime)) * rowWidth;

      // Draw red-white-black cursor
      context.lineWidth = 5; context.strokeStyle = 'red';
      context.beginPath(); context.moveTo(xPos + .5, 0); context.lineTo(xPos + .5, ROW_HEIGHT); context.stroke();
      context.lineWidth = 3; context.strokeStyle = 'white';
      context.beginPath(); context.moveTo(xPos + .5, 0); context.lineTo(xPos + .5, ROW_HEIGHT); context.stroke();
      context.lineWidth = 1; context.strokeStyle = 'black';
      context.beginPath(); context.moveTo(xPos + .5, 0); context.lineTo(xPos + .5, ROW_HEIGHT); context.stroke();
    });
  }

  // === Control Event Listeners ===
  startGenerateButton.addEventListener('click', () => {
    if (!fileInput.files[0]) return alert('Choose an MP3 file.');
    if (audioContext) { audioContext.close(); audioContext = null; }
    audioContext = new AudioContext();

    generatePhaseAudio = new Audio(URL.createObjectURL(fileInput.files[0]));
    generatePhaseAudio.crossOrigin = 'anonymous';
    generatePhaseAudio.playbackRate = parseFloat(playbackSpeedSelect.value);

    audioAnalyzer = audioContext.createAnalyser();
    const sourceNode = audioContext.createMediaElementSource(generatePhaseAudio);
    sourceNode.connect(audioAnalyzer);
    audioAnalyzer.connect(audioContext.destination);
    audioFrequencyData = new Uint8Array(audioAnalyzer.frequencyBinCount);

    drawXPosition = 0;
    spectrogramCompleted = false;
    finalRowDrawWidth = 0;
    rowsContainer.innerHTML = '';
    spectrogramRows.length = 0;
    cursorOverlayRows.length = 0;
    notationContextRows.length = 0;
    rowStartTimeMarkers.length = 0;

    createSpectrogramRow();
    generatePhaseAudio.play();
    pauseGenerateButton.disabled = false;
    drawSpectrogramFrame();
  });

  pauseGenerateButton.addEventListener('click', () => {
    if (!generatePhaseAudio) return;
    if (generatePhaseAudio.paused) {
      generatePhaseAudio.play();
      drawSpectrogramFrame();
    } else {
      generatePhaseAudio.pause();
      cancelAnimationFrame(spectrogramAnimationId);
    }
  });

  fileInput.addEventListener('change', () => {
    if (!fileInput.files[0]) {
      timeStatus.textContent = 'No file loaded.';
      fileDurationStatus.textContent = '';
      return;
    }
    const probeAudio = document.createElement('audio');
    probeAudio.src = URL.createObjectURL(fileInput.files[0]);
    probeAudio.addEventListener('loadedmetadata', () => {
      fileDurationStatus.textContent = 'Total Duration: ' + formatTime(probeAudio.duration);
    });
  });

  rewind15Seconds.addEventListener('click', () => {
    if (!playbackPhaseAudio) return;
    playbackPhaseAudio.currentTime = Math.max(0, playbackPhaseAudio.currentTime - 15);
    drawPlaybackCursor();
  });

  forward15Seconds.addEventListener('click', () => {
    if (!playbackPhaseAudio) return;
    playbackPhaseAudio.currentTime = Math.min(playbackPhaseAudio.duration, playbackPhaseAudio.currentTime + 15);
    drawPlaybackCursor();
  });

  playPauseButton.addEventListener('click', () => {
    if (!playbackPhaseAudio) return;
    isPlayingBack ? playbackPhaseAudio.pause() : playbackPhaseAudio.play();
  });

  exportButton.addEventListener('click', () => {
    // Merge all spectrogram rows into one canvas
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = SCREEN_WIDTH;
    exportCanvas.height = spectrogramRows.length * ROW_HEIGHT;
    const exportContext = exportCanvas.getContext('2d');
    spectrogramRows.forEach(({ canvas }, idx) => {
      exportContext.drawImage(canvas, 0, idx * ROW_HEIGHT);
    });
    const link = document.createElement('a');
    link.download = 'spectrogram.png';
    link.href = exportCanvas.toDataURL();
    link.click();
  });

  // === Edit Mode Controls ===
  editModeToggle.addEventListener('click', () => {
    isEditMode = !isEditMode;
    editModeToggle.textContent = isEditMode ? 'Switch to Seek Mode' : 'Switch to Edit Mode';
    // change cursor for overlay canvases
    cursorOverlayRows.forEach(({ canvas }) => {
      canvas.style.pointerEvents = isEditMode ? 'none' : 'auto';
    });
  });

  highlightColorPicker.addEventListener('input', () => {
    currentHighlightColor = highlightColorPicker.value;
  });
  eraserButton.addEventListener('click', () => {
    currentHighlightColor = 'eraser';
  });
</script>
</body>
</html>
