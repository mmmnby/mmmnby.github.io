


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Responsive 24-Hour World Timer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: linear-gradient(to bottom, #e0f0ff, #a0d0ff);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      touch-action: manipulation;
    }
    #clockCanvas { display: block; }
    #digitalClock, #localTimeContainer {
      margin-top: 0.5em;
      font-size: 1.1em;
      font-weight: 500;
      text-align: center;
      color: #333;
    }
    #zoneButtonsContainer {
      margin-top: 10px;
    }
    #zoneButtonsContainer button {
      font-size: 1.2em;
      padding: 0.3em 0.8em;
      margin: 0 0.5em;
      cursor: pointer;
      border: 1px solid #999;
      background: #fff;
      border-radius: 4px;
    }
    #timeZoneSlider {
      width: 90vw;
      max-width: 500px;
      height: 2em;
      margin: 1em auto;
      background: #ddd;
      border-radius: 0.25em;
      touch-action: none;
      user-select: none;
      position: relative;
    }
    #timeZoneSlider::after {
      content: 'Swipe to change zone';
      position: absolute;
      width: 100%;
      text-align: center;
      line-height: 2em;
      color: #777;
      font-size: 0.8em;
      pointer-events: none;
    }
    #timeZoneSlider:active { background: #ccc; }
  </style>
</head>
<body>

  <canvas id="clockCanvas"></canvas>

  <div id="digitalClock"></div>

  <div id="localTimeContainer">
    <span id="localTimeDisplay"></span>
  </div>

  <div id="zoneButtonsContainer">
    <button id="decreaseZoneButton">←</button>
    <button id="increaseZoneButton">→</button>
  </div>

  <div id="timeZoneSlider"></div>

  <script>
    const worldMapImage = new Image();
    worldMapImage.src = 'worldmap.jpg'; // Ensure this file exists
    worldMapImage.onload = onWindowResize;

    const clockCanvasElement    = document.getElementById('clockCanvas');
    const canvasContext         = clockCanvasElement.getContext('2d');
    const digitalClockElement   = document.getElementById('digitalClock');
    const localTimeElement      = document.getElementById('localTimeDisplay');
    const increaseZoneButton    = document.getElementById('increaseZoneButton');
    const decreaseZoneButton    = document.getElementById('decreaseZoneButton');
    const timeZoneSliderElement = document.getElementById('timeZoneSlider');

    const timeZones = [
      { city: 'Pago Pago',  offset: -11 },
      { city: 'Honolulu',   offset: -10 },
      { city: 'Anchorage',  offset:  -9 },
      { city: 'Los Angls',  offset:  -8 },
      { city: 'Denver',     offset:  -7 },
      { city: 'MexicoCit',  offset:  -6 },
      { city: 'New York',   offset:  -5 },
      { city: 'Santiago',   offset:  -4 },
      { city: 'BuenosAir',  offset:  -3 },
      { city: 'Ponta Del',  offset:  -2 },
      { city: 'Azores',     offset:  -1 },
      { city: 'London',     offset:   0 },
      { city: 'Berlin',     offset:  +1 },
      { city: 'Cairo',      offset:  +2 },
      { city: 'Moscow',     offset:  +3 },
      { city: 'Dubai',      offset:  +4 },
      { city: 'Karachi',    offset:  +5 },
      { city: 'Dhaka',      offset:  +6 },
      { city: 'Bangkok',    offset:  +7 },
      { city: 'Beijing',    offset:  +8 },
      { city: 'Tokyo',      offset:  +9 },
      { city: 'Sydney',     offset: +10 },
      { city: 'Noumea',     offset: +11 },
      { city: 'Auckland',   offset: +12 }
    ];

    const browserUtcOffset = -new Date().getTimezoneOffset() / 60;
    let currentZoneIndex = timeZones.findIndex(z => z.offset === browserUtcOffset);
    if (currentZoneIndex < 0) currentZoneIndex = 11; // London default

    function onWindowResize() {
      // Make the canvas fit nicely
      const canvasSize = Math.min(window.innerWidth, window.innerHeight) * 0.85;
      clockCanvasElement.width  = canvasSize;
      clockCanvasElement.height = canvasSize;
      
      // Handle High DPI displays for crisp text
      const dpr = window.devicePixelRatio || 1;
      clockCanvasElement.style.width = canvasSize + "px";
      clockCanvasElement.style.height = canvasSize + "px";
      clockCanvasElement.width = canvasSize * dpr;
      clockCanvasElement.height = canvasSize * dpr;
      canvasContext.scale(dpr, dpr);

      drawClockFace();
      updateDigitalClock();
      updateLocalTime();
    }

    window.addEventListener('resize', onWindowResize);
    window.addEventListener('orientationchange', onWindowResize);

    function drawClockFace() {
      const size   = parseFloat(clockCanvasElement.style.width);
      const center = size / 2;
      const radius = center * 0.95; 

      canvasContext.clearRect(0, 0, size, size);
      
      canvasContext.save();
      canvasContext.translate(center, center);

      // ───────────────────────────────────────────────
      //  Calculate rotation so current UTC hour is at top
      // ───────────────────────────────────────────────
      const nowUtc = new Date();
      let utcHours = nowUtc.getUTCHours() + nowUtc.getUTCMinutes() / 60 + nowUtc.getUTCSeconds() / 3600;
      
      const rotationForCurrentTime = - (utcHours - 12) * (Math.PI / 12);

      // ── Apply rotation to map, day/night, numbers, cities ──
      canvasContext.save();
      canvasContext.rotate(rotationForCurrentTime);

      // 1. Draw Map (Clipped)
      const mapRadius = radius * 0.55;
      canvasContext.save();
      canvasContext.beginPath();
      canvasContext.arc(0, 0, mapRadius, 0, Math.PI * 2);
      canvasContext.clip();

      if (worldMapImage.complete && worldMapImage.naturalWidth > 0) {
        canvasContext.drawImage(worldMapImage, -mapRadius, -mapRadius, mapRadius * 2, mapRadius * 2);
      } else {
        // Fallback if image missing
        canvasContext.fillStyle = '#a0d0ff';
        canvasContext.fill();
        canvasContext.fillStyle = '#80c0ff';
        canvasContext.textAlign = 'center';
        canvasContext.fillText("Map", 0, 0);
      }
      canvasContext.restore();

      // 2. Day/Night Shader
      drawDayNightOverlay(mapRadius);

      // 4. Numbers (24h) and Cities
      drawHourNumbersAndCities(radius, mapRadius);

      canvasContext.restore();

      // 3. Borders (unrotated circle)
      drawClockBorder(radius, mapRadius);

      // 5. Hour Hand (Triangle pointer fixed at top)
      drawHourHandFixedAtTop(mapRadius);
      
      canvasContext.restore();
    }

    function drawClockBorder(outerRadius, innerRadius) {
      // Just a clean stroke around the map
      canvasContext.beginPath();
      canvasContext.arc(0, 0, innerRadius, 0, Math.PI * 2);
      canvasContext.lineWidth = 2;
      canvasContext.strokeStyle = '#333';
      canvasContext.stroke();
    }

    function drawHourNumbersAndCities(outerRadius, mapRadius) {
  // -- CONFIG --
  const numberRingRadius = mapRadius + (outerRadius - mapRadius) * 0.15;
  const cityRingRadius   = mapRadius + (outerRadius - mapRadius) * 0.55;
  
  const numFontSize = outerRadius * 0.05;
  const cityFontSize = outerRadius * 0.055;

  // Background ring radii (slightly larger than text to create padding)
  const bgInnerRadius = numberRingRadius - numFontSize * 1.1;
  const bgOuterRadius = numberRingRadius + numFontSize * 1.1;

  // ── Draw segmented background rings first ──
  canvasContext.save();
  canvasContext.lineWidth = bgOuterRadius - bgInnerRadius;

  for (let h = 0; h < 24; h++) {
    const angle = (h - 12) * Math.PI / 12 - Math.PI / 2;
    const startAngle = angle - Math.PI / 24;
    const endAngle   = angle + Math.PI / 24;

    let isDarkSegment = (h >= 19 || h <= 6); // 18–24 and 0–6 (but 0 shown as 24 or 0)

    canvasContext.beginPath();
    canvasContext.arc(0, 0, numberRingRadius, startAngle, endAngle);
    canvasContext.strokeStyle = isDarkSegment ? '#1e1e1e' : '#f0f0f0'; // very dark vs very light grey
    canvasContext.lineCap = 'butt';
    canvasContext.stroke();
  }
  canvasContext.restore();

  // ── Now draw the numbers on top ──
  canvasContext.font = `bold ${numFontSize}px sans-serif`;
  canvasContext.textAlign = 'center';
  canvasContext.textBaseline = 'middle';

  for (let h = 0; h < 24; h++) {
    const displayNumber = h === 0 ? 24 : h; // optional: show 0 as 24
    const angle = (h - 12) * Math.PI / 12 - Math.PI / 2;
    
    const x = numberRingRadius * Math.cos(angle);
    const y = numberRingRadius * Math.sin(angle);

    const isDarkSegment = (h >= 19 || h <= 6);

    canvasContext.save();
    canvasContext.translate(x, y);
    canvasContext.rotate(angle + Math.PI / 2); 
    
    // White text on dark background segments, dark text on light segments
    canvasContext.fillStyle = isDarkSegment ? '#ffffff' : '#222222';
    canvasContext.fillText(displayNumber, 0, 0);
    
    canvasContext.restore();
  }

  // ── City names (unchanged) ──
  canvasContext.font = `600 ${cityFontSize}px sans-serif`;
  
  const offsetAngle = (Math.PI / 2) - (Math.PI / 12); 

  timeZones.forEach((zone, i) => {
    const angle = offsetAngle - (i * (Math.PI / 12));
    const stagger = (i % 2 === 0) ? 0 : (outerRadius * 0.08);
    const r = cityRingRadius + stagger;

    const x = r * Math.cos(angle);
    const y = r * Math.sin(angle);

    canvasContext.save();
    canvasContext.translate(x, y);

    if (y < 0) {
      canvasContext.rotate(angle + Math.PI / 2);
    } else {
      canvasContext.rotate(angle - Math.PI / 2);
    }

    canvasContext.fillStyle = '#222';
    canvasContext.fillText(zone.city, 0, 0);
    canvasContext.restore();
  });
}

    function drawHourHandFixedAtTop(mapRadius) {
      // Because we rotated the ring so current time is at top,
      // we now just draw the pointer straight up (at angle = -π/2)
      const handLen = mapRadius * 0.15;

      canvasContext.save();
      // No need to calculate angle — it's always at top after ring rotation
      canvasContext.rotate(-Math.PI / 2);           // point to 12 o'clock position
      canvasContext.translate(mapRadius * 1.05, 0); // move to edge of map

      canvasContext.beginPath();
      canvasContext.moveTo(0, 0);
      canvasContext.lineTo(-handLen, -handLen/2);
      canvasContext.lineTo(-handLen,  handLen/2);
      canvasContext.closePath();
      
      canvasContext.fillStyle = 'red';
      canvasContext.fill();
      
      // Optional: thin stem line
      canvasContext.beginPath();
      canvasContext.moveTo(0, 0);
      canvasContext.lineTo(-mapRadius * 0.02, 0);
      canvasContext.strokeStyle = 'red';
      canvasContext.lineWidth = 3;
      canvasContext.stroke();

      canvasContext.restore();
    }

    function drawDayNightOverlay(mapRadius) {
      // Basic visualization of where it is currently night
      // Noon (Sun) is at top? No, usually Noon is fixed or rotating.
      // Since map is static North-up, the shadow rotates.
      // UTC 12:00 = Sun over Greenwich (roughly).
      
      const nowUtc = new Date();
      const h = nowUtc.getUTCHours() + nowUtc.getUTCMinutes()/60;
      
      // Sun position rotates 15 deg/hour.
      // At UTC 12, Sun is at 0 longitude (Greenwich).
      // If Map is centered on North Pole, 0 lat is usually down or up?
      // Assuming standard image projection where UK is top-ish/center.
      
      // Simplified: Just rotate the shadow based on time.
      // 12 UTC = Day at Top. Night at Bottom.
      const angle = (h / 24) * Math.PI * 2; // 0..2PI

      canvasContext.save();
      canvasContext.rotate(angle + Math.PI); // Rotate the "Night" part
      
      canvasContext.beginPath();
      // Draw a semi-circle for night
      canvasContext.arc(0, 0, mapRadius, 0, Math.PI); 
      canvasContext.fillStyle = 'rgba(0, 0, 50, 0.3)';
      canvasContext.fill();
      
      canvasContext.restore();
    }

    function updateDigitalClock() {
      const now = new Date();
      const h = String(now.getUTCHours()).padStart(2, '0');
      const m = String(now.getUTCMinutes()).padStart(2, '0');
      const s = String(now.getUTCSeconds()).padStart(2, '0');
      digitalClockElement.textContent = `UTC: ${h}:${m}:${s}`;
    }

    function formatUtcOffset(offset) {
      const sign = offset >= 0 ? '+' : '−';
      return `UTC${sign}${Math.abs(offset)}`;
    }

    function updateLocalTime() {
      const now = new Date();
      const utcH = now.getUTCHours();
      const utcM = now.getUTCMinutes();
      const utcS = now.getUTCSeconds();
      
      const zone = timeZones[currentZoneIndex];
      const off = zone.offset;

      // Calculate local time
      let locH = (utcH + off) % 24;
      if (locH < 0) locH += 24;
      
      const locHStr = String(Math.floor(locH)).padStart(2, '0');
      const locMStr = String(utcM).padStart(2, '0');
      const locSStr = String(utcS).padStart(2, '0');

      const offStr = formatUtcOffset(off);
      localTimeElement.textContent = `${locHStr}:${locMStr}:${locSStr} — ${zone.city} (${offStr})`;
    }

    // Interaction Handlers
    increaseZoneButton.addEventListener('click', () => {
      currentZoneIndex = (currentZoneIndex + 1) % timeZones.length;
      updateLocalTime();
    });

    decreaseZoneButton.addEventListener('click', () => {
      currentZoneIndex = (currentZoneIndex - 1 + timeZones.length) % timeZones.length;
      updateLocalTime();
    });

    // Swipe Logic
    let touchStartX = 0;
    timeZoneSliderElement.addEventListener('touchstart', e => {
      touchStartX = e.touches[0].clientX;
    }, {passive: false});

    timeZoneSliderElement.addEventListener('touchend', e => {
      const touchEndX = e.changedTouches[0].clientX;
      const diff = touchEndX - touchStartX;
      if (Math.abs(diff) > 50) {
        if (diff > 0) {
           // Swipe Right -> Decrease Index
           currentZoneIndex = (currentZoneIndex - 1 + timeZones.length) % timeZones.length;
        } else {
           // Swipe Left -> Increase Index
           currentZoneIndex = (currentZoneIndex + 1) % timeZones.length;
        }
        updateLocalTime();
      }
    }, {passive: false});

    // Init
    onWindowResize();
    setInterval(() => {
      drawClockFace();
      updateDigitalClock();
      updateLocalTime();
    }, 1000);
  </script>
</body>
</html>
