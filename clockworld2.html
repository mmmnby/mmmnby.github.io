<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Prevent mobile pinch-zoom & enforce responsive scaling -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Responsive 24-Hour Clock</title>
  <style>
    /* ─── Base page styles ───────────────────────────────────────────────────── */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: sans-serif;
      /* Disable double-tap zoom on mobile browsers */
      touch-action: manipulation;
    }

    /* Canvas for analog clock */
    canvas {
      display: block;
    }

    /* Container for digital and local time displays */
    #digital, #local-container {
      margin-top: 0.5em;
      font-size: 1em;
      text-align: center;
      touch-action: manipulation;
    }

    /* Buttons to cycle time zones */
    #local-container button {
      font-size: 1em;
      padding: 0.2em 0.6em;
      margin: 0 0.5em;
      touch-action: manipulation;
    }

    /* Slider bar for swipe-to-change-zone control */
    #slider {
      width: 90vw;
      max-width: 500px;
      height: 2em;
      margin: 0.5em auto;
      background: #ddd;
      border-radius: 0.25em;
      user-select: none;
      touch-action: none;        /* capture all pointer events */
    }
    #slider:active {
      background: #ccc;
    }
  </style>
</head>
<body>
  <!-- Analog clock -->
  <canvas id="clock"></canvas>

  <!-- UTC digital readout -->
  <div id="digital">--:--:-- GMT</div>

  <!-- Local time with prev/next zone buttons -->
  <div id="local-container">
    <button id="tz-minus">←</button>
    <span id="local-time">--:--:-- City (UTC+0)</span>
    <button id="tz-plus">→</button>
  </div>

  <!-- Invisible swipe bar for zone changing -->
  <div id="slider"></div>

  <script>
  (function() {
    'use strict';

    // ─── Constants & Element References ────────────────────────────────────────

    const canvas     = document.getElementById('clock'),
          ctx        = canvas.getContext('2d'),
          digitalEl  = document.getElementById('digital'),
          localEl    = document.getElementById('local-time'),
          btnNext    = document.getElementById('tz-plus'),
          btnPrev    = document.getElementById('tz-minus'),
          slider     = document.getElementById('slider');

    // World map image for clock background
    const mapImg = new Image();
    mapImg.src   = 'worldmap.jpg';

    // 24 major cities spanning UTC-11 … +12 (unchanged)
    const zones = [
      { city: 'Pago Pago',    offset: -11 },
      { city: 'Honolulu',     offset: -10 },
      { city: 'Anchorage',    offset:  -9 },
      { city: 'Los Angeles',  offset:  -8 },
      { city: 'Denver',       offset:  -7 },
      { city: 'Mexico City',  offset:  -6 },
      { city: 'New York',     offset:  -5 },
      { city: 'Santiago',     offset:  -4 },
      { city: 'Buenos Aires', offset:  -3 },
      { city: 'Ponta Del',    offset:  -2 },
      { city: 'Azores',       offset:  -1 },
      { city: 'London',       offset:   0 },
      { city: 'Berlin',       offset:  +1 },
      { city: 'Cairo',        offset:  +2 },
      { city: 'Moscow',       offset:  +3 },
      { city: 'Dubai',        offset:  +4 },
      { city: 'Karachi',      offset:  +5 },
      { city: 'Dhaka',        offset:  +6 },
      { city: 'Bangkok',      offset:  +7 },
      { city: 'Beijing',      offset:  +8 },
      { city: 'Tokyo',        offset:  +9 },
      { city: 'Sydney',       offset: +10 },
      { city: 'Nouméa',       offset: +11 },
      { city: 'Auckland',     offset: +12 }
    ];

    // Determine initial zone index from browser's UTC offset
    const browserOffset = -new Date().getTimezoneOffset() / 60;
    let zoneIndex = zones.findIndex(z => z.offset === browserOffset);
    if (zoneIndex < 0) zoneIndex = 11;  // fallback to London

    // ─── Responsive Initialization ───────────────────────────────────────────

    // Resize canvas to viewport width and trigger initial draw
    function resizeCanvas() {
      const size = window.innerWidth;
      canvas.width = size;
      canvas.height = size;
      drawAll();        // draws both analog and updates texts
    }

    // Listen for resize & orientation events
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', resizeCanvas);
    // Also wait until map image is ready
    mapImg.onload = resizeCanvas;

    // ─── Main Draw & Update Loop ─────────────────────────────────────────────

    // Draw analog clock + update digital/local displays
    function drawAll() {
      drawAnalogClock();
      updateDigitalUTC();
      updateLocalTime();
    }

    // Use requestAnimationFrame for smooth 1-second updates
    (function tick() {
      drawAll();
      setTimeout(() => requestAnimationFrame(tick), 1000);
    })();

    // ─── Analog Clock Rendering ──────────────────────────────────────────────

    function drawAnalogClock() {
      const W = canvas.width,
            C = W / 2,
            R = C * 0.70;         // main radius

      // Reset transforms & clear
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0, 0, W, W);
      ctx.translate(C, C);

      // Clip to circle for map background
      ctx.save();
      ctx.beginPath();
      ctx.arc(0, 0, R, 0, 2*Math.PI);
      ctx.clip();
      if (mapImg.complete) {
        ctx.drawImage(mapImg, -R, -R, 2*R, 2*R);
        drawDayNightOverlay(R);
      }
      ctx.restore();

      drawClockFace(R, W);
      drawHourMarkers(R, W);
      drawHourHands(R);
    }

    // Semi-transparent half-circle rotating overlay (day/night)
    function drawDayNightOverlay(R) {
      const now    = new Date(),
            h      = now.getUTCHours(),
            m      = now.getUTCMinutes(),
            fraction = (h + m/60) / 24,
            start   = fraction * 2*Math.PI + 1.5*Math.PI;

      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,R, start, start + Math.PI);
      ctx.closePath();
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fill();
    }

    // Outer circle & tick marks
    function drawClockFace(R, W) {
      ctx.beginPath();
      ctx.arc(0, 0, R, 0, 2*Math.PI);
      ctx.lineWidth   = Math.max(2, W * 0.008);
      ctx.strokeStyle = '#000';
      ctx.stroke();
    }

    // Draw 96 ticks plus dual 24-hour rings
    function drawHourMarkers(R, W) {
      const majorLen = R * 0.10,
            midLen   = R * 0.066,
            minorLen = R * 0.033,
            ring1    = R * 1.10,
            ring2    = R * 1.30;

      ctx.font         = `${Math.max(10, R*0.08)}px sans-serif`;
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'middle';

      // 96 tick marks (4 per hour)
      for (let i = 0; i < 96; i++) {
        const angle = i * 2*Math.PI/96 + 1.5*Math.PI,
              isHour = i % 4 === 0,
              isHalf = i % 2 === 0,
              len    = isHour ? majorLen : isHalf ? midLen : minorLen,
              outerR = R,
              innerR = R - len;

        ctx.beginPath();
        ctx.lineWidth = isHour ? Math.max(3, W*0.01) : Math.max(1, W*0.004);
        ctx.moveTo(outerR * Math.cos(angle), outerR * Math.sin(angle));
        ctx.lineTo(innerR * Math.cos(angle), innerR * Math.sin(angle));
        ctx.strokeStyle = '#000';
        ctx.stroke();
      }

      // Dual 24-hour numeric rings
      for (let utcHour = 0; utcHour < 24; utcHour++) {
        const ang    = utcHour * 2*Math.PI/24 + 0.5*Math.PI,
              x1     = ring1 * Math.cos(ang),
              y1     = ring1 * Math.sin(ang),
              localH = (utcHour + zones[zoneIndex].offset + 24) % 24,
              x2     = ring2 * Math.cos(ang),
              y2     = ring2 * Math.sin(ang);

        // UTC ring (always black)
        ctx.fillStyle = '#000';
        ctx.fillText(utcHour, x1, y1);

        // Local ring (12 in red)
        ctx.fillStyle = (localH === 12) ? 'red' : '#000';
        ctx.fillText(localH, x2, y2);
      }
    }

    // Single hour-hand pointing to current UTC hour/fraction
    function drawHourHands(R) {
      const now    = new Date(),
            h      = now.getUTCHours(),
            m      = now.getUTCMinutes(),
            fraction = (h + m/60) / 24,
            angle   = fraction * 2*Math.PI + 1.5*Math.PI,
            length  = R - (R * 0.10) + 2,
            width   = Math.max(14, R * 0.07);

      ctx.save();
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(-width/2, 0);
      ctx.lineTo(0, -length);
      ctx.lineTo(width/2, 0);
      ctx.closePath();
      ctx.fillStyle = '#000';
      ctx.fill();
      ctx.restore();
    }

    // ─── Digital UTC & Local Time Updates ────────────────────────────────────

    function updateDigitalUTC() {
      const now = new Date(),
            hh  = String(now.getUTCHours()).padStart(2, '0'),
            mm  = String(now.getUTCMinutes()).padStart(2, '0'),
            ss  = String(now.getUTCSeconds()).padStart(2, '0');
      digitalEl.textContent = `${hh}:${mm}:${ss} GMT`;
    }

    function updateLocalTime() {
      const utcMs    = Date.now(),
            offsetH  = zones[zoneIndex].offset,
            localMs  = utcMs + offsetH * 3600e3,
            d        = new Date(localMs),
            hh       = String(d.getHours()).padStart(2, '0'),
            mm       = String(d.getMinutes()).padStart(2, '0'),
            ss       = String(d.getSeconds()).padStart(2, '0'),
            { city } = zones[zoneIndex],
            sign     = offsetH >= 0 ? '+' : '−',
            offStr   = `UTC${sign}${Math.abs(offsetH)}`;
      localEl.textContent = `${hh}:${mm}:${ss} ${city} (${offStr})`;
    }

    // ─── Zone Switching: Buttons & Swipe Slider ──────────────────────────────

    btnNext.addEventListener('click', () => {
      zoneIndex = (zoneIndex + 1) % zones.length;
      drawAll();
    });
    btnPrev.addEventListener('click', () => {
      zoneIndex = (zoneIndex - 1 + zones.length) % zones.length;
      drawAll();
    });

    // Swipe detection on #slider to change zones
    (function enableSwipeZoneChange() {
      const step = window.innerWidth / 7;  // pixels per zone increment
      let startX, startZone;

      slider.addEventListener('touchstart', e => {
        e.preventDefault();
        startX     = e.touches[0].clientX;
        startZone  = zoneIndex;
      });

      slider.addEventListener('touchmove', e => {
        e.preventDefault();
        const dx     = e.touches[0].clientX - startX,
              delta  = Math.round(dx / step),
              newIdx = (startZone + delta + zones.length) % zones.length;
        if (newIdx !== zoneIndex) {
          zoneIndex = newIdx;
          drawAll();
        }
      });
    })();

    // ─── Kick-off ────────────────────────────────────────────────────────────
    // Initial sizing and drawing
    resizeCanvas();
  })();
  </script>
</body>
</html>
