<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- 1) Added user-scalable=no to prevent pinch & double-tap zoom -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Responsive 24-Hour Clock with Double Outer Rings</title>
  <style>
    /* 2) touch-action: manipulation stops double-tap/zoom gestures */
    html, body {
      margin: 0; padding: 0;
      height: 100%;
      background: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: sans-serif;
      touch-action: manipulation;
    }
    canvas { display: block; }
    #digital, #local-container {
      margin-top: 0.5em;
      font-size: 1em;
      text-align: center;
      touch-action: manipulation;
    }
    #local-container button {
      font-size: 1em;
      padding: 0.2em 0.6em;
      margin: 0 0.5em;
      touch-action: manipulation;
    }

      /* ─── Slider container (the “wide rectangle”) ─── */
/* slider track under the time displays */
#slider {
  width: 90vw;
  max-width: 500px;
  height: 2em;
  margin: 0.5em auto;
  background: #ddd;
  border-radius: 0.25em;
  touch-action: none;
  user-select: none;
}
#slider:active {
  background: #ccc;
}
    
  </style>
</head>
<body>
  <canvas id="clock"></canvas>
  <div id="digital"></div>

  <!-- Local time display with arrows -->
  <div id="local-container">
    <button id="tz-minus">←</button>
    <span id="local-time"></span>
    <button id="tz-plus">→</button>
  </div>
  <!-- slider: drag left/right to change zones -->
  <div id="slider"></div>
  
  <script>
    const mapImg  = new Image();
    mapImg.src    = 'worldmap.jpg';
    mapImg.onload = resize;

    const canvas    = document.getElementById('clock'),
          ctx       = canvas.getContext('2d'),
          digitalEl = document.getElementById('digital'),
          localEl   = document.getElementById('local-time'),
          btnPlus   = document.getElementById('tz-plus'),
          btnMinus  = document.getElementById('tz-minus');

    // Array of 24 major cities covering UTC-11…+12
    const zones = [
      { city: 'Pago Pago',     offset: -11 },
      { city: 'Honolulu',      offset: -10 },
      { city: 'Anchorage',     offset:  -9 },
      { city: 'Los Angeles',   offset:  -8 },
      { city: 'Denver',        offset:  -7 },
      { city: 'Mexico City',   offset:  -6 },
      { city: 'New York',      offset:  -5 },
      { city: 'Santiago',      offset:  -4 },
      { city: 'Buenos Aires',  offset:  -3 },
      { city: 'Ponta Del', offset:  -2 },
      { city: 'Azores',        offset:  -1 },
      { city: 'London',        offset:   0 },
      { city: 'Berlin',        offset:  +1 },
      { city: 'Cairo',         offset:  +2 },
      { city: 'Moscow',        offset:  +3 },
      { city: 'Dubai',         offset:  +4 },
      { city: 'Karachi',       offset:  +5 },
      { city: 'Dhaka',         offset:  +6 },
      { city: 'Bangkok',       offset:  +7 },
      { city: 'Beijing',       offset:  +8 },
      { city: 'Tokyo',         offset:  +9 },
      { city: 'Sydney',        offset: +10 },
      { city: 'Nouméa',        offset: +11 },
      { city: 'Auckland',      offset: +12 }
    ];

    // Find browser's current UTC offset in hours (e.g. -8 for PDT)
    const browserOffset = -new Date().getTimezoneOffset() / 60;
    let zoneIndex = zones.findIndex(z => z.offset === browserOffset);
    if (zoneIndex < 0) zoneIndex = 11;  // default to London if no match

    function resize() {
      const W = window.innerWidth;
      canvas.width  = W;
      canvas.height = W;
      drawClock();
      updateDigital();
      updateLocal();
    }
    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', resize);

    function drawClock() {
      const W = canvas.width,
            C = W / 2,
            R = C * 0.70;

      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0, 0, W, W);
      ctx.translate(C, C);

      ctx.save();
      ctx.beginPath();
      ctx.arc(0, 0, R, 0, Math.PI*2);
      ctx.clip();

      if (mapImg.complete) {
        ctx.drawImage(mapImg, -R, -R, 2*R, 2*R);
      }
      drawRotatingOverlay(R);
      ctx.restore();

      drawFace(R, W);
      drawNumbers(R);
      drawHourHand(R);
    }

    function drawFace(R, W) {
      const majorLen = R * 0.10,
            midLen   = R * 0.066,
            minorLen = R * 0.033;

      ctx.beginPath();
      ctx.arc(0, 0, R, 0, Math.PI*2);
      ctx.lineWidth   = Math.max(2, W * 0.008);
      ctx.strokeStyle = '#000';
      ctx.stroke();

      for (let i = 0; i < 96; i++) {
        const angle  = i * 2*Math.PI/96 + 3*Math.PI/2,
              isHour = i % 4 === 0,
              isHalf = i % 2 === 0,
              len    = isHour ? majorLen : isHalf ? midLen : minorLen,
              oR     = R,
              iR     = R - len;

        ctx.beginPath();
        ctx.moveTo(oR * Math.cos(angle), oR * Math.sin(angle));
        ctx.lineTo(iR * Math.cos(angle), iR * Math.sin(angle));
        ctx.lineWidth   = isHour ? Math.max(3, W*0.01) : Math.max(1, W*0.004);
        ctx.strokeStyle = '#000';
        ctx.stroke();
      }
    }

    

    function drawNumbers(R) {
      const fontSize = Math.max(10, R * 0.08);
      ctx.font         = `${fontSize}px sans-serif`;
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'middle';

      const ring1 = R * 1.10,
            ring2 = R * 1.30;

      for (let num = 0; num < 24; num++) {
        const angle = num * 2*Math.PI/24 + Math.PI/2,
              x1    = ring1 * Math.cos(angle),
              y1    = ring1 * Math.sin(angle),
              local = (num + zones[zoneIndex].offset + 24) % 24,
              x2    = ring2 * Math.cos(angle),
              y2    = ring2 * Math.sin(angle);

        // Draw inner ring (UTC hour) in black
        ctx.fillStyle = '#000';
        ctx.fillText(num, x1, y1);

        // Draw outer ring (local hour) - make 12 red
        if (local === 12) {
          ctx.fillStyle = 'red';
        } else {
          ctx.fillStyle = '#000';
        }
        ctx.fillText(local, x2, y2);
      }
    }


    function drawHourHand(R) {
      const now   = new Date(),
            h     = (now.getUTCHours() + 0 + 24) % 24,
            m     = now.getUTCMinutes(),
            frac  = (h + m/60) / 24,
            angle = frac * 2*Math.PI + 2*Math.PI/2,
            len   = R - (R * 0.10) + 2,
            w     = Math.max(14, R * 0.07);

      ctx.save();
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(-w/2, 0);
      ctx.lineTo(0, -len);
      ctx.lineTo(w/2, 0);
      ctx.closePath();
      ctx.fillStyle = '#000';
      ctx.fill();
      ctx.restore();
    }

    function drawRotatingOverlay(R) {
      const now        = new Date(),
            h          = (now.getUTCHours() + 0 + 24) % 24,
            m          = now.getUTCMinutes(),
            frac       = (h + m/60) / 24,
            A          = frac * 2 * Math.PI + Math.PI/2,
            startAngle = A + Math.PI/2;

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, R, startAngle, startAngle + Math.PI);
      ctx.closePath();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fill();
    }

    function updateDigital() {
      const now = new Date(),
            h   = (now.getUTCHours() + 0 + 24) % 24,
            m   = now.getUTCMinutes(),
            s   = now.getUTCSeconds(),
            hh  = String(h).padStart(2,'0'),
            mm  = String(m).padStart(2,'0'),
            ss  = String(s).padStart(2,'0');
      digitalEl.textContent = `${hh}:${mm}:${ss} UTC`;
    }

    function fmtOffset(n) {
      const sign = n >= 0 ? '+' : '−',
            absO = Math.abs(n);
      return `UTC${sign}${absO}`;
    }

    function updateLocal() {
      const nowUtc   = Date.now(),
            offHours = zones[zoneIndex].offset,
            localMs  = nowUtc + offHours * 3600e3,
            d        = new Date(localMs),
            hh       = String(d.getUTCHours()).padStart(2,'0'),
            mm       = String(d.getMinutes()).padStart(2,'0'),
            ss       = String(d.getSeconds()).padStart(2,'0'),
            city     = zones[zoneIndex].city,
            offStr   = fmtOffset(offHours);

      localEl.textContent = `${hh}:${mm}:${ss} ${city} (${offStr})`;
    }

    btnPlus.addEventListener('click', () => {
      zoneIndex = (zoneIndex + 1) % zones.length;
      updateLocal();
      drawClock();
    });
    btnMinus.addEventListener('click', () => {
      zoneIndex = (zoneIndex - 1 + zones.length) % zones.length;
      updateLocal();
      drawClock();
    });

    // kick things off
    resize();
    setInterval(() => {
      drawClock();
      updateDigital();
      updateLocal();
    }, 1000);


    
const slider   = document.getElementById('slider'),
      screenW  = window.innerWidth,
      stepPx   = screenW / 7;   // ≈7 zone-steps per full swipe

let startX, startZone;

slider.addEventListener('touchstart', e => {
  e.preventDefault();
  startX     = e.touches[0].clientX;
  startZone  = zoneIndex;
});

slider.addEventListener('touchmove', e => {
  e.preventDefault();
  const dx     = e.touches[0].clientX - startX,
        delta  = Math.round(dx / stepPx),
        newZI  = ((startZone + delta) % zones.length + zones.length) % zones.length;

  if (newZI !== zoneIndex) {
    zoneIndex = newZI;
    updateLocal();
    drawClock();
  }
});
  </script>
</body>
</html>
