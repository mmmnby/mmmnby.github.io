


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Responsive 24-Hour World Timer</title>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%;
      background: linear-gradient(to bottom, #e0f0ff, #a0d0ff);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      touch-action: manipulation;
    }
    #clockCanvas { display: block; }
    #digitalClock, #localTimeContainer {
      margin-top: 0.5em; font-size: 1.1em; font-weight: 500;
      text-align: center; color: #333;
    }
    #zoneButtonsContainer { margin-top: 10px; }
    #zoneButtonsContainer button {
      font-size: 1.2em; padding: 0.3em 0.8em; margin: 0 0.5em;
      cursor: pointer; border: 1px solid #999; background: #fff; border-radius: 4px;
    }
    #timeZoneSlider {
      width: 90vw; max-width: 500px; height: 2em; margin: 1em auto;
      background: #ddd; border-radius: 0.25em; position: relative;
    }
    #timeZoneSlider::after {
      content: 'Swipe to change zone';
      position: absolute; width: 100%; text-align: center;
      line-height: 2em; color: #777; font-size: 0.8em; pointer-events: none;
    }
  </style>
</head>
<body>

  <canvas id="clockCanvas"></canvas>
  <div id="digitalClock"></div>
  <div id="localTimeContainer"><span id="localTimeDisplay"></span></div>
  <div id="zoneButtonsContainer">
    <button id="decreaseZoneButton">←</button>
    <button id="increaseZoneButton">→</button>
  </div>
  <div id="timeZoneSlider"></div>

  <script>
    /**
     * --- RADIUS COEFFICIENTS CONFIGURATION ---
     * All values are ratios relative to the Universal Radius (1.0).
     * This section allows for easy UI scaling maintenance.
     */
    const SCALING_CONFIG = {
      outerStaticNumbers: 0.96, // The stationary 0-23 numbers
      tickRing:           0.90, // The outer minute/hour tick track
      redArrowOrbit:      0.88, // Orbit path for the 24h Red Hand
      minArrowOrbit:      0.88, // Orbit path for the Pink Minute Hand
      rotatingCityRing:   0.78, // Distance for city names
      rotatingHourRing:   0.60, // Distance for the 24h rotating disk numbers
      worldMap:           0.52, // Radius of the center world map
    };

    const worldMapImage = new Image();
    worldMapImage.src = 'worldmap.jpg'; 
    worldMapImage.onload = onWindowResize;

    const clockCanvasElement    = document.getElementById('clockCanvas');
    const canvasContext         = clockCanvasElement.getContext('2d');
    const digitalClockElement   = document.getElementById('digitalClock');
    const localTimeElement      = document.getElementById('localTimeDisplay');
    const increaseZoneButton    = document.getElementById('increaseZoneButton');
    const decreaseZoneButton    = document.getElementById('decreaseZoneButton');
    const timeZoneSliderElement = document.getElementById('timeZoneSlider');

    const timeZones = [
      { city: 'Pago Pago',  offset: -11 }, { city: 'Honolulu',   offset: -10 },
      { city: 'Anchorage',  offset:  -9 }, { city: 'Los Angls',  offset:  -8 },
      { city: 'Denver',     offset:  -7 }, { city: 'MexicoCit',  offset:  -6 },
      { city: 'New York',   offset:  -5 }, { city: 'Santiago',   offset:  -4 },
      { city: 'BuenosAir',  offset:  -3 }, { city: 'Ponta Del',  offset:  -2 },
      { city: 'Azores',     offset:  -1 }, { city: 'London',     offset:   0 },
      { city: 'Berlin',     offset:  +1 }, { city: 'Cairo',      offset:  +2 },
      { city: 'Moscow',     offset:  +3 }, { city: 'Dubai',      offset:  +4 },
      { city: 'Karachi',    offset:  +5 }, { city: 'Dhaka',      offset:  +6 },
      { city: 'Bangkok',    offset:  +7 }, { city: 'Beijing',    offset:  +8 },
      { city: 'Tokyo',      offset:  +9 }, { city: 'Sydney',     offset: +10 },
      { city: 'Noumea',     offset: +11 }, { city: 'Auckland',   offset: +12 }
    ];

    const browserUtcOffset = -new Date().getTimezoneOffset() / 60;
    let currentZoneIndex = timeZones.findIndex(z => z.offset === browserUtcOffset);
    if (currentZoneIndex < 0) currentZoneIndex = 11; 

    function onWindowResize() {
      const canvasSize = Math.min(window.innerWidth, window.innerHeight) * 0.85;
      const dpr = window.devicePixelRatio || 1;
      clockCanvasElement.style.width = canvasSize + "px";
      clockCanvasElement.style.height = canvasSize + "px";
      clockCanvasElement.width = canvasSize * dpr;
      clockCanvasElement.height = canvasSize * dpr;
      canvasContext.scale(dpr, dpr);
      drawClockFace();
    }

    window.addEventListener('resize', onWindowResize);
    window.addEventListener('orientationchange', onWindowResize);

    /**
     * MAIN DRAWING FUNCTION
     */
    function drawClockFace() {
      const size = parseFloat(clockCanvasElement.style.width);
      const center = size / 2;

      /**
       * --- UNIVERSAL RADIUS DEFINITION ---
       * This is the base unit (1.0) from which all other elements scale.
       */
      const universalRadius = center;

      /**
       * --- PIXEL CALCULATION BLOCK ---
       * Local variables calculated from coefficients for easy maintenance.
       */
      const r_StaticNums = universalRadius * SCALING_CONFIG.outerStaticNumbers;
      const r_TickRing   = universalRadius * SCALING_CONFIG.tickRing;
      const r_RedOrbit   = universalRadius * SCALING_CONFIG.redArrowOrbit;
      const r_MinOrbit   = universalRadius * SCALING_CONFIG.minArrowOrbit;
      const r_CityRing   = universalRadius * SCALING_CONFIG.rotatingCityRing;
      const r_HourRing   = universalRadius * SCALING_CONFIG.rotatingHourRing;
      const r_Map        = universalRadius * SCALING_CONFIG.worldMap;

      canvasContext.clearRect(0, 0, size, size);
      canvasContext.save();
      canvasContext.translate(center, center);

      // 1. Draw Map
      drawWorldMap(r_Map);

      // 2. Draw Static Elements
      drawOuterTickRing(r_TickRing);
      drawOuterStaticNumberRing(r_StaticNums);

      // 3. Draw Dynamic (Rotating) Rings
      drawRotatingRings(r_HourRing, r_CityRing, r_Map, r_TickRing);

      // 4. Draw Distinct Orbit Pointers
      drawLocalTimePointer(r_RedOrbit); 
      drawMinutePointer(r_MinOrbit);

      canvasContext.restore();
    }

    function drawWorldMap(radius) {
      canvasContext.save();
      canvasContext.beginPath();
      canvasContext.arc(0, 0, radius, 0, Math.PI * 2);
      canvasContext.clip();
      if (worldMapImage.complete && worldMapImage.naturalWidth > 0) {
        canvasContext.drawImage(worldMapImage, -radius, -radius, radius * 2, radius * 2);
      } else {
        canvasContext.fillStyle = '#a0d0ff';
        canvasContext.fill();
      }
      canvasContext.strokeStyle = '#333';
      canvasContext.lineWidth = 2;
      canvasContext.stroke();
      canvasContext.restore();
    }

    function drawOuterTickRing(radius) {
      canvasContext.beginPath();
      canvasContext.arc(0, 0, radius, 0, Math.PI * 2);
      canvasContext.lineWidth = 3.5;
      canvasContext.strokeStyle = '#666';
      canvasContext.stroke();

      for (let i = 0; i < 60; i++) {
        const angle = (i * Math.PI / 30) - Math.PI / 2;
        const isMajor = (i % 5 === 0);
        const len = isMajor ? radius * 0.06 : radius * 0.04;
        canvasContext.beginPath();
        canvasContext.moveTo(radius * Math.cos(angle), radius * Math.sin(angle));
        canvasContext.lineTo((radius - len) * Math.cos(angle), (radius - len) * Math.sin(angle));
        canvasContext.lineWidth = isMajor ? 2.5 : 1.2;
        canvasContext.strokeStyle = isMajor ? '#333' : '#888';
        canvasContext.stroke();
      }
    }

    function drawOuterStaticNumberRing(radius) {
      const fontSize = radius * 0.08;
      canvasContext.font = `bold ${fontSize}px sans-serif`;
      canvasContext.textAlign = 'center';
      canvasContext.textBaseline = 'middle';
      canvasContext.fillStyle = '#444';

      for (let i = 0; i < 24; i++) {
        const angle = (i * Math.PI / 12) + Math.PI / 2;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        canvasContext.save();
        canvasContext.translate(x, y);
        canvasContext.rotate((i >= 6 && i <= 18) ? angle + Math.PI/2 : angle - Math.PI/2);
        canvasContext.fillText(i, 0, 0);
        canvasContext.restore();
      }
    }

    function drawRotatingRings(hourRad, cityRad, innerBound, outerBound) {
      const now = new Date();
      const currentUtcHour = now.getUTCHours();
      const numFontSize = hourRad * 0.15;
      const cityFontSize = hourRad * 0.16;

      // Draw Hour Background Segments
      canvasContext.save();
      for (let h = 0; h < 24; h++) {
        const angle = ((currentUtcHour - h) * Math.PI / 12) - Math.PI / 2;
        canvasContext.beginPath();
        canvasContext.arc(0, 0, hourRad, angle - Math.PI/24, angle + Math.PI/24);
        canvasContext.lineWidth = hourRad * 0.4;
        canvasContext.strokeStyle = (h >= 19 || h <= 6) ? '#1e1e1e' : '#f0f0f0';
        canvasContext.stroke();
      }
      canvasContext.restore();

      // Draw Hour Numbers
      canvasContext.font = `bold ${numFontSize}px sans-serif`;
      for (let h = 0; h < 24; h++) {
        const angle = ((currentUtcHour - h) * Math.PI / 12) - Math.PI / 2;
        const x = hourRad * Math.cos(angle);
        const y = hourRad * Math.sin(angle);
        canvasContext.save();
        canvasContext.translate(x, y);
        canvasContext.rotate(angle - Math.PI / 2);
        canvasContext.fillStyle = (h >= 19 || h <= 6) ? '#fff' : '#222';
        canvasContext.fillText(h, 0, 0);
        canvasContext.restore();
      }

      // Draw City Names
      canvasContext.font = `600 ${cityFontSize}px sans-serif`;
      timeZones.forEach((zone, i) => {
        const angle = -Math.PI/2 - (zone.offset * (Math.PI / 12));
        const stagger = (i % 2 === 0) ? 0 : (hourRad * 0.2);
        const r = cityRad + stagger;
        canvasContext.save();
        canvasContext.translate(r * Math.cos(angle), r * Math.sin(angle));
        canvasContext.rotate(angle + (Math.sin(angle) < 0 ? Math.PI/2 : -Math.PI/2));
        canvasContext.fillStyle = '#222';
        canvasContext.fillText(zone.city, 0, 0);
        canvasContext.restore();
      });
    }

    function drawLocalTimePointer(orbitRadius) {
      const now = new Date();
      const hrs = now.getHours() + (now.getMinutes() / 60) + (now.getSeconds() / 3600);
      const angle = ((hrs - 12) * Math.PI / 12) - Math.PI / 2;
      const pLen = orbitRadius * 0.13; 
      const pWid = pLen / 2.2;

      canvasContext.save();
      canvasContext.rotate(angle);
      canvasContext.translate(orbitRadius, 0); 
      
      const grad = canvasContext.createLinearGradient(0, 0, pLen, 0);
      grad.addColorStop(0, '#ff4d4d'); grad.addColorStop(1, '#991900');

      canvasContext.beginPath();
      canvasContext.moveTo(0, 0); canvasContext.lineTo(pLen, -pWid); canvasContext.lineTo(pLen, pWid);
      canvasContext.closePath();
      canvasContext.fillStyle = grad;
      canvasContext.fill();
      canvasContext.strokeStyle = '#fff';
      canvasContext.lineWidth = 2;
      canvasContext.stroke();
      canvasContext.restore();
    }

    function drawMinutePointer(orbitRadius) {
      const now = new Date();
      const mins = now.getMinutes() + (now.getSeconds() / 60);
      const angle = (mins * Math.PI / 30) - Math.PI / 2;
      const pLen = (orbitRadius * 0.13) * 0.65; 
      const pWid = pLen / 2.2;

      canvasContext.save();
      canvasContext.rotate(angle);
      canvasContext.translate(orbitRadius, 0); 

      const grad = canvasContext.createLinearGradient(0, 0, -pLen, 0);
      grad.addColorStop(0, '#FF00FF'); grad.addColorStop(1, '#D100D1');

      canvasContext.beginPath();
      canvasContext.moveTo(0, 0); canvasContext.lineTo(-pLen, -pWid); canvasContext.lineTo(-pLen, pWid);
      canvasContext.closePath();
      canvasContext.fillStyle = grad;
      canvasContext.fill();
      canvasContext.strokeStyle = '#fff';
      canvasContext.lineWidth = 1.5;
      canvasContext.stroke();
      canvasContext.restore();
    }

    // --- Helpers & Updates ---
    function updateDigitalClock() {
      const now = new Date();
      digitalClockElement.textContent = `UTC: ${now.getUTCHours().toString().padStart(2,'0')}:${now.getUTCMinutes().toString().padStart(2,'0')}:${now.getUTCSeconds().toString().padStart(2,'0')}`;
    }

    function updateLocalTime() {
      const now = new Date();
      const zone = timeZones[currentZoneIndex];
      let locH = (now.getUTCHours() + zone.offset + 24) % 24;
      localTimeElement.textContent = `${Math.floor(locH).toString().padStart(2,'0')}:${now.getUTCMinutes().toString().padStart(2,'0')}:${now.getUTCSeconds().toString().padStart(2,'0')} — ${zone.city} (UTC${zone.offset >=0 ? '+':''}${zone.offset})`;
    }

    increaseZoneButton.onclick = () => { currentZoneIndex = (currentZoneIndex + 1) % timeZones.length; updateLocalTime(); };
    decreaseZoneButton.onclick = () => { currentZoneIndex = (currentZoneIndex - 1 + timeZones.length) % timeZones.length; updateLocalTime(); };

    setInterval(() => { drawClockFace(); updateDigitalClock(); updateLocalTime(); }, 1000);
    onWindowResize();
  </script>
</body>
</html>


