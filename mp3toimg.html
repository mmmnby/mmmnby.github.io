<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Streamed MP3 Spectrogram</title>
  <style>
    body { background:#111; color:white; text-align:center; font-family:sans-serif; padding:20px; }
    canvas { background:black; border:1px solid #444; display:block; margin:20px auto; }
    .controls { margin:20px; }
    button, select, input { padding:6px 12px; font-size:16px; margin:5px; }
    #status { margin-top:10px; font-style:italic; color:#ccc; }
    #status.error { color:#f55; }
    audio { display:none; }
  </style>
</head>
<body>
  <h1>Streamed MP3 Spectrogram</h1>

  <div class="controls">
    <input type="file" id="fileInput" accept=".mp3">
    <select id="chunkSelect" disabled></select>
    <button id="processBtn" disabled>Process Chunk</button>
    <button id="saveBtn" disabled>Save PNG</button>
    <div id="status">Select an MP3 file to start.</div>
  </div>

  <canvas id="canvas" width="1000" height="256"></canvas>
  <audio id="audio" controls></audio>

  <script>
    const fileInput = document.getElementById('fileInput');
    const chunkSelect = document.getElementById('chunkSelect');
    const processBtn = document.getElementById('processBtn');
    const saveBtn = document.getElementById('saveBtn');
    const status = document.getElementById('status');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const audio = document.getElementById('audio');

    const CHUNK_SIZE = 10 * 1024 * 1024; // 10 MB
    const segmentSec = 600; // 10 minutes
    const FFT_SIZE = 512;
    const HOP = FFT_SIZE / 2;

    let file, chunks = [];

    function setStatus(msg, err=false) {
      status.textContent = "Status: " + msg;
      status.classList.toggle('error', err);
      console.log(msg);
    }

    fileInput.onchange = () => {
      file = fileInput.files[0];
      if (!file) return;
      chunks = [];
      const total = Math.ceil(file.size / CHUNK_SIZE);
      for (let i = 0; i < total; i++) {
        chunks.push(i);
      }
      chunkSelect.innerHTML = chunks.map(i => `<option value="${i}">Chunk ${i+1}/${chunks.length}</option>`).join('');
      chunkSelect.disabled = false;
      processBtn.disabled = false;
      setStatus(`${chunks.length} chunks ready.`);
    };

    processBtn.onclick = async () => {
      saveBtn.disabled = true;
      const idx = parseInt(chunkSelect.value);
      setStatus(`Appending chunk ${idx+1}...`);
      try {
        const mediaSrc = new MediaSource();
        audio.src = URL.createObjectURL(mediaSrc);
        mediaSrc.addEventListener('sourceopen', async () => {
          const sb = mediaSrc.addSourceBuffer('audio/mpeg');
          const start = idx * CHUNK_SIZE;
          const end = Math.min(start + CHUNK_SIZE, file.size);
          const slice = file.slice(start, end);
          const data = await slice.arrayBuffer();
          sb.appendBuffer(data);

          sb.addEventListener('updateend', async () => {
            mediaSrc.endOfStream();
            audio.currentTime = 0;
            audio.play();

            setStatus('Decoding with OfflineAudioContext...');
            setTimeout(async () => {
              audio.pause();
              const buffer = await decodeChunk(audio, segmentSec);
              renderSpectrogram(buffer);
              setStatus(`Rendered chunk ${idx+1}`);
              saveBtn.disabled = false;
              URL.revokeObjectURL(audio.src);
            }, 500); // small pause to preload
          });
        });
      } catch (e) {
        setStatus('Error streaming chunk: ' + e.message, true);
        console.error(e);
      }
    };

    async function decodeChunk(audioElem, durationSec) {
      const sr = 8000;
      const off = new OfflineAudioContext(1, sr * durationSec, sr);
      const src = off.createMediaElementSource(audioElem);
      src.connect(off.destination);
      audioElem.currentTime = 0;
      audioElem.playbackRate = off.sampleRate / audioElem.sampleRate;
      audioElem.muted = true;
      audioElem.play();
      await off.startRendering();
      audioElem.pause();
      return off;
    }

    function renderSpectrogram(buffer) {
      const data = buffer.getChannelData(0);
      ctx.fillStyle = 'black';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      const fft = new FFT(FFT_SIZE);
      const bins = FFT_SIZE/2;
      for (let x=0; x<canvas.width-60; x++) {
        const start = x * HOP;
        if (start + FFT_SIZE > data.length) break;
        const frame = new Float32Array(FFT_SIZE);
        for (let i=0;i<FFT_SIZE;i++) frame[i]=data[start+i] * (0.5*(1-Math.cos(2*Math.PI*i/(FFT_SIZE-1))));
        const out = fft.createComplexArray();
        fft.realTransform(out,frame); fft.completeSpectrum(out);
        for (let y=0;y<bins && y<canvas.height;y++) {
          const re=out[2*y], im=out[2*y+1], mag=Math.sqrt(re*re+im*im);
          const dB=Math.log10(mag+1)*40; const hue=Math.min(255,Math.floor(dB*5));
          ctx.fillStyle=`hsl(${hue},100%,50%)`;
          ctx.fillRect(x+60,canvas.height-1-y,1,1);
        }
      }
      drawLabels(buffer.sampleRate);
    }

    function drawLabels(sr) {
      ctx.fillStyle='white'; ctx.font='12px sans-serif';
      ctx.textAlign='right'; ctx.textBaseline='middle';
      const ny = sr/2;
      for (let i=0;i<=4;i++) {
        const y=(i/4)*canvas.height;
        ctx.fillText(((4-i)/4*ny).toFixed(0)+'Hz',58,y);
      }
      ctx.textAlign='center'; ctx.textBaseline='top';
      for (let i=0;i<=10;i++) {
        const x=60+i*((canvas.width-60)/10);
        ctx.fillText(i+'s',x,canvas.height-12);
      }
    }

    saveBtn.onclick = () => {
      const link = document.createElement('a');
      link.download = 'spectrogram.png';
      link.href = canvas.toDataURL();
      link.click();
    };

    // FFT class as before (omitted due to brevity)...

    class FFT {
      constructor(size) {
        this.size = size;
        this._csize = size<<1;
        this._table = new Float64Array(size*2);
        for (let i=0;i<size;i++){
          const a=Math.PI*i/size;
          this._table[i*2]=Math.cos(a);this._table[i*2+1]=-Math.sin(a);}
        this._rev=new Uint32Array(size);
        const lg=Math.log2(size);
        for (let i=0;i<size;i++) this._rev[i]=this._rev[i]=[...Array(lg)].reduce((y,_,$)=>(y<<1)|(i>>(lg-$-1)&1),0);
      }
      createComplexArray(){return new Float64Array(this._csize);}
      realTransform(out,data){
        const sz=this.size;
        for(let i=0;i<sz;i++){out[2*this._rev[i]]=data[i];out[2*this._rev[i]+1]=0;}
        for(let step=1;step<sz;step<<=1){
          const jump=step<<1,delta=sz/jump;
          for(let i=0;i<sz;i+=jump){
            for(let j=0;j<step;j++){
              const idx=j*delta, tRe=this._table[2*idx], tIm=this._table[2*idx+1];
              const i0=(i+j)<<1, i1=(i+j+step)<<1;
              const re0=out[i0],im0=out[i0+1], re1=out[i1],im1=out[i1+1];
              const tre=re1*tRe - im1*tIm, tim=re1*tIm+im1*tRe;
              out[i1]=re0-tre;out[i1+1]=im0-tim;
              out[i0]=re0+tre;out[i0+1]=im0+tim;
            }
          }
        }
      }
      completeSpectrum(out){
        const sz=this.size;
        for(let i=1;i<sz/2;i++){
          out[(sz-i)*2]=out[i*2];
          out[(sz-i)*2+1]=-out[i*2+1];
        }
      }
    }
  </script>
</body>
</html>
