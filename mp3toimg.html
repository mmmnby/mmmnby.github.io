<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MP3 to Full Spectrogram</title>
    <style>
        body {
            background-color: #111;
            color: #fff;
            font-family: sans-serif;
            text-align: center;
            padding: 20px;
        }
        canvas {
            background-color: black;
            display: block;
            margin: 20px auto;
            border: 1px solid #444;
        }
    </style>
</head>
<body>
    <h1>MP3 to Full Spectrogram</h1>
    <input type="file" id="audioInput" accept=".mp3">
    <canvas id="spectrogram" width="1000" height="256"></canvas>

    <!-- Include FFT.js -->
    <script src="https://cdn.jsdelivr.net/npm/fft.js/dist/fft.min.js"></script>

    <script>
        const audioInput = document.getElementById('audioInput');
        const canvas = document.getElementById('spectrogram');
        const ctx = canvas.getContext('2d');

        function getColor(value) {
            return `hsl(${value}, 100%, 50%)`;
        }

        audioInput.addEventListener('change', async function () {
            const file = this.files[0];
            if (!file) {
                alert('Please select an MP3 file.');
                return;
            }

            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

            const channelData = audioBuffer.getChannelData(0); // Use left channel only
            const sampleRate = audioBuffer.sampleRate;

            const fftSize = 512;
            const fft = new FFT(fftSize);
            const bins = fftSize / 2;

            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            const hopSize = fftSize / 2;
            const totalFrames = Math.floor((channelData.length - fftSize) / hopSize);
            const step = Math.floor(totalFrames / canvasWidth);

            const input = new Array(fftSize).fill(0);
            const output = fft.createComplexArray();

            // Clear canvas before drawing
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            for (let i = 0; i < canvasWidth; i++) {
                const start = i * step * hopSize;
                for (let j = 0; j < fftSize; j++) {
                    input[j] = channelData[start + j] || 0;
                }

                // Apply Hann window (for smoother transitions)
                for (let j = 0; j < fftSize; j++) {
                    input[j] *= 0.5 * (1 - Math.cos((2 * Math.PI * j) / (fftSize - 1)));
                }

                fft.realTransform(output, input);
                fft.completeSpectrum(output);

                for (let y = 0; y < bins && y < canvasHeight; y++) {
                    const re = output[2 * y];
                    const im = output[2 * y + 1];
                    const mag = Math.sqrt(re * re + im * im);

                    const norm = Math.min(255, Math.floor(255 * Math.log10(1 + mag)));
                    ctx.fillStyle = getColor(norm);
                    ctx.fillRect(i, canvasHeight - 1 - y, 1, 1);
                }
            }

            alert('Spectrogram rendered!');
        });
    </script>
</body>
</html>
