<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hour-Long MP3 Spectrogram Viewer</title>
  <style>
    body {
      background: #111;
      color: white;
      font-family: sans-serif;
      text-align: center;
    }
    canvas {
      background: black;
      margin: 20px auto;
      border: 1px solid #555;
      display: block;
    }
    .controls {
      margin: 10px auto;
    }
    button, select, input[type="number"] {
      padding: 8px;
      font-size: 14px;
      margin: 6px;
    }
    #status {
      margin-top: 8px;
      font-style: italic;
      color: #ccc;
    }
    #status.error {
      color: red;
    }
  </style>
</head>
<body>
  <h1>Spectrogram Viewer (for Hour-Long MP3s)</h1>

  <div class="controls">
    <input type="file" id="audioInput" accept=".mp3">
    <label for="scale">Seconds/pixel:</label>
    <select id="scale">
      <option value="0.2">0.2</option>
      <option value="0.5">0.5</option>
      <option value="1" selected>1</option>
      <option value="2">2</option>
      <option value="5">5</option>
      <option value="10">10</option>
    </select>

    <label for="slice">Slice (min):</label>
    <input type="number" id="sliceStart" value="0" min="0" step="1">
    <button id="prevSlice">◀</button>
    <button id="nextSlice">▶</button>
    <button id="processBtn">Process Slice</button>
    <button id="saveBtn" disabled>Save Image</button>
    <div id="status">Status: Waiting for file...</div>
  </div>

  <canvas id="spectrogram" width="1200" height="300"></canvas>

  <script>
    class FFT {
      constructor(size) {
        this.size = size;
        this._csize = size << 1;
        this._table = new Float64Array(size * 2);
        for (let i = 0; i < size; i++) {
          const angle = (Math.PI * i) / size;
          this._table[i * 2] = Math.cos(angle);
          this._table[i * 2 + 1] = -Math.sin(angle);
        }
        this._rev = new Uint32Array(size);
        const log2 = Math.log2(size);
        for (let i = 0; i < size; i++) {
          this._rev[i] = this._reverseBits(i, log2);
        }
      }
      _reverseBits(x, bits) {
        let y = 0;
        for (let i = 0; i < bits; i++) {
          y = (y << 1) | (x & 1);
          x >>>= 1;
        }
        return y;
      }
      createComplexArray() {
        return new Float64Array(this._csize);
      }
      realTransform(out, data) {
        const size = this.size;
        for (let i = 0; i < size; i++) {
          out[2 * this._rev[i]] = data[i];
          out[2 * this._rev[i] + 1] = 0;
        }
        for (let step = 1; step < size; step <<= 1) {
          const jump = step << 1;
          const delta = size / jump;
          for (let i = 0; i < size; i += jump) {
            for (let j = 0; j < step; j++) {
              const idx = j * delta;
              const tRe = this._table[2 * idx];
              const tIm = this._table[2 * idx + 1];
              const i0 = (i + j) << 1;
              const i1 = (i + j + step) << 1;
              const re0 = out[i0];
              const im0 = out[i0 + 1];
              const re1 = out[i1];
              const im1 = out[i1 + 1];
              const tre = re1 * tRe - im1 * tIm;
              const tim = re1 * tIm + im1 * tRe;
              out[i1] = re0 - tre;
              out[i1 + 1] = im0 - tim;
              out[i0] = re0 + tre;
              out[i0 + 1] = im0 + tim;
            }
          }
        }
      }
      completeSpectrum(out) {
        const size = this.size;
        for (let i = 1; i < size / 2; i++) {
          out[(size - i) * 2] = out[i * 2];
          out[(size - i) * 2 + 1] = -out[i * 2 + 1];
        }
      }
    }

    const canvas = document.getElementById('spectrogram');
    const ctx = canvas.getContext('2d');
    const processBtn = document.getElementById('processBtn');
    const saveBtn = document.getElementById('saveBtn');
    const audioInput = document.getElementById('audioInput');
    const scaleSelect = document.getElementById('scale');
    const status = document.getElementById('status');
    const sliceStartInput = document.getElementById('sliceStart');
    const prevSliceBtn = document.getElementById('prevSlice');
    const nextSliceBtn = document.getElementById('nextSlice');

    let audioBuffer = null;

    function setStatus(msg, isError = false) {
      status.textContent = "Status: " + msg;
      status.classList.toggle('error', isError);
    }

    audioInput.addEventListener('change', async () => {
      setStatus("Decoding audio...");
      try {
        const file = audioInput.files[0];
        const arrayBuffer = await file.arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        setStatus("Audio loaded. Duration: " + audioBuffer.duration.toFixed(1) + "s");
      } catch (e) {
        console.error(e);
        setStatus("Error decoding audio", true);
      }
    });

    prevSliceBtn.onclick = () => {
      const val = parseInt(sliceStartInput.value, 10);
      if (val > 0) sliceStartInput.value = val - 10;
    };
    nextSliceBtn.onclick = () => {
      sliceStartInput.value = parseInt(sliceStartInput.value, 10) + 10;
    };

    processBtn.addEventListener('click', async () => {
      if (!audioBuffer) {
        setStatus("No audio loaded", true);
        return;
      }

      setStatus("Processing...");
      processBtn.disabled = true;
      saveBtn.disabled = true;

      const secondsPerPixel = parseFloat(scaleSelect.value);
      const fftSize = 512;
      const hopSize = fftSize / 2;
      const bins = fftSize / 2;
      const sampleRate = audioBuffer.sampleRate;
      const marginLeft = 60;
      const marginBottom = 20;
      const height = 256;
      const width = 1024;
      canvas.width = width + marginLeft;
      canvas.height = height + marginBottom;
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const sliceStartMin = parseInt(sliceStartInput.value, 10) || 0;
      const sliceStartSec = sliceStartMin * 60;
      const sliceEndSec = sliceStartSec + secondsPerPixel * width;
      const startSample = Math.floor(sliceStartSec * sampleRate);
      const endSample = Math.min(audioBuffer.length, Math.floor(sliceEndSec * sampleRate));
      const slice = audioBuffer.getChannelData(0).slice(startSample, endSample);

      const fft = new FFT(fftSize);
      const input = new Float64Array(fftSize);
      const output = fft.createComplexArray();
      const frames = Math.floor((slice.length - fftSize) / hopSize);
      const pixels = Math.min(frames, width);

      for (let px = 0; px < pixels; px++) {
        const offset = px * hopSize;
        for (let i = 0; i < fftSize; i++) {
          input[i] = slice[offset + i] * 0.5 * (1 - Math.cos((2 * Math.PI * i) / (fftSize - 1)));
        }
        fft.realTransform(output, input);
        fft.completeSpectrum(output);

        for (let y = 0; y < bins && y < height; y++) {
          const re = output[2 * y];
          const im = output[2 * y + 1];
          const mag = Math.sqrt(re * re + im * im);
          const dB = Math.log10(mag + 1) * 40;
          const hue = Math.min(255, Math.floor(dB * 5));
          ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
          ctx.fillRect(px + marginLeft, height - y - 1, 1, 1);
        }
      }

      // Y-axis frequency labels
      ctx.fillStyle = "white";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      const nyquist = sampleRate / 2;
      for (let y = 0; y <= 4; y++) {
        const pos = (y / 4) * height;
        const freq = ((4 - y) / 4) * nyquist;
        ctx.fillText(freq.toFixed(0) + " Hz", marginLeft - 4, pos);
      }

      // X-axis time labels
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      const start = sliceStartSec;
      const totalTime = secondsPerPixel * width;
      for (let x = 0; x <= 10; x++) {
        const pos = x * (width / 10);
        const t = start + (x / 10) * totalTime;
        ctx.fillText(t.toFixed(1) + "s", pos + marginLeft, height + 2);
      }

      setStatus("Done!");
      saveBtn.disabled = false;
      processBtn.disabled = false;
    });

    saveBtn.addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'spectrogram.png';
      link.href = canvas.toDataURL();
      link.click();
    });
  </script>
</body>
</html>
