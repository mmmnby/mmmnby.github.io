<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MP3 Spectrogram Viewer (10-min Paging)</title>
  <style>
    body {
      background: #111;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      display: block;
      margin: 20px auto;
      background: black;
      border: 1px solid #555;
    }
    .controls {
      margin: 20px 0;
    }
    button, select {
      font-size: 16px;
      padding: 6px 12px;
      margin: 6px;
    }
    #status {
      margin-top: 10px;
      font-style: italic;
      color: #ccc;
    }
    #status.error {
      color: red;
    }
  </style>
</head>
<body>
  <h1>MP3 Spectrogram Viewer</h1>

  <div class="controls">
    <input type="file" id="audioInput" accept=".mp3">
    <button id="processBtn">Load & Process</button><br>

    <button id="prevBtn" disabled>◀ Prev</button>
    <button id="nextBtn" disabled>Next ▶</button>
    <button id="saveBtn" disabled>Save Image</button>

    <div id="status">Waiting for file...</div>
  </div>

  <canvas id="spectrogram" width="1000" height="256"></canvas>

  <script>
    const canvas = document.getElementById("spectrogram");
    const ctx = canvas.getContext("2d");

    const processBtn = document.getElementById("processBtn");
    const saveBtn = document.getElementById("saveBtn");
    const nextBtn = document.getElementById("nextBtn");
    const prevBtn = document.getElementById("prevBtn");
    const fileInput = document.getElementById("audioInput");
    const statusText = document.getElementById("status");

    let audioBuffer = null;
    let pageIndex = 0;
    const sliceDuration = 600; // 10 minutes in seconds
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    const fftSize = 512;
    const hopSize = fftSize / 2;
    const bins = fftSize / 2;

    function setStatus(msg, isError = false) {
      statusText.textContent = "Status: " + msg;
      statusText.classList.toggle("error", isError);
    }

    function drawLabels(sampleRate) {
      ctx.fillStyle = "white";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      const nyquist = sampleRate / 2;

      for (let y = 0; y <= 4; y++) {
        const pos = (y / 4) * canvasHeight;
        const freq = ((4 - y) / 4) * nyquist;
        ctx.fillText(freq.toFixed(0) + " Hz", 58, pos);
      }

      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      const timePerPixel = sliceDuration / canvasWidth;
      for (let x = 0; x <= 10; x++) {
        const px = 60 + x * ((canvasWidth - 60) / 10);
        const seconds = pageIndex * sliceDuration + x * (sliceDuration / 10);
        const label = (seconds / 60).toFixed(1) + " min";
        ctx.fillText(label, px, canvasHeight - 12);
      }
    }

    async function renderPage(index) {
      if (!audioBuffer) return;

      const data = audioBuffer.getChannelData(0);
      const sampleRate = audioBuffer.sampleRate;
      const startSample = Math.floor(index * sliceDuration * sampleRate);
      const endSample = Math.min(startSample + (sliceDuration * sampleRate), data.length);

      const frameCount = Math.floor((endSample - startSample - fftSize) / hopSize);
      const pixels = Math.min(canvasWidth - 60, frameCount);
      const fft = new FFT(fftSize);
      const input = new Array(fftSize).fill(0);
      const output = fft.createComplexArray();

      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);

      for (let x = 0; x < pixels; x++) {
        const offset = startSample + x * hopSize;
        if (offset + fftSize >= data.length) break;

        for (let i = 0; i < fftSize; i++) {
          const sample = data[offset + i] || 0;
          const window = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (fftSize - 1)));
          input[i] = sample * window;
        }

        fft.realTransform(output, input);
        fft.completeSpectrum(output);

        for (let y = 0; y < bins && y < canvasHeight; y++) {
          const re = output[2 * y];
          const im = output[2 * y + 1];
          const mag = Math.sqrt(re * re + im * im);
          const dB = Math.log10(mag + 1) * 40;
          const hue = Math.min(255, Math.floor(dB * 5));
          ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
          ctx.fillRect(x + 60, canvasHeight - 1 - y, 1, 1);
        }

        if (x % 100 === 0) await new Promise(r => requestAnimationFrame(r));
      }

      drawLabels(sampleRate);
      saveBtn.disabled = false;
      setStatus(`Showing page ${pageIndex + 1}`);
    }

    processBtn.addEventListener("click", async () => {
      const file = fileInput.files[0];
      if (!file) return setStatus("Please select an MP3 file first.", true);

      processBtn.disabled = true;
      setStatus("Loading and decoding...");

      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const buffer = await file.arrayBuffer();
        audioBuffer = await audioCtx.decodeAudioData(buffer);
        pageIndex = 0;

        const totalSlices = Math.ceil(audioBuffer.duration / sliceDuration);
        nextBtn.disabled = totalSlices <= 1;
        prevBtn.disabled = true;

        await renderPage(pageIndex);
      } catch (err) {
        console.error(err);
        setStatus("Error decoding audio: " + err.message, true);
      } finally {
        processBtn.disabled = false;
      }
    });

    nextBtn.addEventListener("click", async () => {
      const totalSlices = Math.ceil(audioBuffer.duration / sliceDuration);
      if (pageIndex < totalSlices - 1) {
        pageIndex++;
        prevBtn.disabled = false;
        if (pageIndex === totalSlices - 1) nextBtn.disabled = true;
        await renderPage(pageIndex);
      }
    });

    prevBtn.addEventListener("click", async () => {
      if (pageIndex > 0) {
        pageIndex--;
        nextBtn.disabled = false;
        if (pageIndex === 0) prevBtn.disabled = true;
        await renderPage(pageIndex);
      }
    });

    saveBtn.addEventListener("click", () => {
      const link = document.createElement("a");
      link.download = `spectrogram_page_${pageIndex + 1}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    });

    // Inlined FFT.js
    class FFT {
      constructor(size) {
        this.size = size;
        this._csize = size << 1;
        this._table = new Float64Array(size * 2);
        for (let i = 0; i < size; i++) {
          const angle = (Math.PI * i) / size;
          this._table[i * 2] = Math.cos(angle);
          this._table[i * 2 + 1] = -Math.sin(angle);
        }
        this._rev = new Uint32Array(size);
        const log2 = Math.log2(size);
        for (let i = 0; i < size; i++) {
          this._rev[i] = this._reverseBits(i, log2);
        }
      }
      _reverseBits(x, bits) {
        let y = 0;
        for (let i = 0; i < bits; i++) {
          y = (y << 1) | (x & 1);
          x >>>= 1;
        }
        return y;
      }
      createComplexArray() {
        return new Float64Array(this._csize);
      }
      realTransform(out, data) {
        const size = this.size;
        for (let i = 0; i < size; i++) {
          out[2 * this._rev[i]] = data[i];
          out[2 * this._rev[i] + 1] = 0;
        }
        for (let step = 1; step < size; step <<= 1) {
          const jump = step << 1;
          const delta = size / jump;
          for (let i = 0; i < size; i += jump) {
            for (let j = 0; j < step; j++) {
              const idx = j * delta;
              const tRe = this._table[2 * idx];
              const tIm = this._table[2 * idx + 1];
              const i0 = (i + j) << 1;
              const i1 = (i + j + step) << 1;
              const re0 = out[i0];
              const im0 = out[i0 + 1];
              const re1 = out[i1];
              const im1 = out[i1 + 1];
              const tre = re1 * tRe - im1 * tIm;
              const tim = re1 * tIm + im1 * tRe;
              out[i1] = re0 - tre;
              out[i1 + 1] = im0 - tim;
              out[i0] = re0 + tre;
              out[i0 + 1] = im0 + tim;
            }
          }
        }
      }
      completeSpectrum(out) {
        const size = this.size;
        for (let i = 1; i < size / 2; i++) {
          out[(size - i) * 2] = out[i * 2];
          out[(size - i) * 2 + 1] = -out[i * 2 + 1];
        }
      }
    }
  </script>
</body>
</html>
